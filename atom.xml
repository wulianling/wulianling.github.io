<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当年明月</title>
  
  <subtitle>那样的夜色，你太美太温柔</subtitle>
  <link href="https://wulianling.github.io/atom.xml" rel="self"/>
  
  <link href="https://wulianling.github.io/"/>
  <updated>2021-11-08T15:36:00.086Z</updated>
  <id>https://wulianling.github.io/</id>
  
  <author>
    <name>TheMoonLight</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cluster-optimization</title>
    <link href="https://wulianling.github.io/2021/11/08/Cluster-optimization/"/>
    <id>https://wulianling.github.io/2021/11/08/Cluster-optimization/</id>
    <published>2021-11-08T12:57:40.000Z</published>
    <updated>2021-11-08T15:36:00.086Z</updated>
    
    <content type="html"><![CDATA[<p>1.集群优化（运维优化）</p><ol><li><p>节点</p><ol><li>相同角色节点，避免使用较大差异的配置</li><li>避免使用 “超大杯”服务器（SS服务器：Super Server）,128核心，1T的内存，2T的硬盘。不仅会赵成资源浪费，而且可能会降低性能。</li><li>等量的配置，使用较少的物理机好于使用较多的虚拟机，5台4核16G内存的物理机，10台甚至11台2核8G 的虚拟机，虚拟机本身消耗性能，还涉及数据安全的问题。</li><li>避免在同一台服务器上部署多个节点。</li></ol></li><li><p><strong>内存</strong>：</p><ol><li>根据业务量的不同，对内存的需求也不一样，一般生产环境建议不要少于16G的内存，尽量不要超过64G。ES本身非常依赖内存，并且ES对内存消耗比较大，内存对ES的重要性是高于CPU，所以即使你的业务数据量不大，为了保证服务的稳定性。在满足业务的前提下，我们仍要考虑有不少于20% 的冗余性能。一般来说。按照百万级、千万级、亿级数据量的索引，我们分别为每个节点分配16G、32G、64G。** 如果性能不足，最好是横向扩容**。</li></ol></li><li><p><strong>磁盘</strong>：</p><ol><li>对于ES来说，磁盘可能是最重要的了，以为数据都是存贮在磁盘上的，当然这里说的磁盘指的是磁盘的性能。磁盘性能往往是计算机性能的瓶颈，木桶效应的最短板。ES应用可能要面临不间断，大量的数据读写。生产环境可以把界定啊冷热分离，热节点使用SSD做存储，可以大幅度提高系统的性能；冷数据存储在机械硬盘中，降低成本。关于磁盘阵列使用raid0</li></ol></li><li><p>cpu：</p><ol><li>cpu 对计算机而言可能是最重要的硬件，对于ES来说他不是最重要的，就是说提升CPU的性能不想提升内存和硬盘收益来的那么直接。服务器的CPU不太需要单核性能，需要的是更多的核心数和线程数，这意味着更高的并发处理能力。</li></ol></li><li><p>网络： </p><ol><li>ES天生自带分布式属性，并且ES的分布式是基于对等网络，节点与节点之间的通信十分频繁，延迟对于ES的用户体验是致命的，低延迟的网络是非常必要的，因此使用跨地域的多个数据中心方案是不可取的。ES可以容忍集群跨多个机房，可以有多个内网，支持夸AZ部署，但是不能接受跨多个地域构建集群，hdfs+Azure az共享data。一旦发生问题，集群直接GG，维护这样的集群额外成本可能远大于它带来的收益。</li></ol></li><li><p>集群规划：</p><ol><li>在集群搭建之前，首先你要考虑清楚，你的ES cluster 的使用目的是什么，主要应用于那些场景，比如是用来存储日志，或者是站内搜索，或者是用于数据的聚合分析，针对不同的应用场景，应该制定不同的优化方案。</li><li>集群需要多少种配置（内存性、IO、运算性），每一种配置需要多少数量，通常需要和产品运营和运维测试商定。 视业务量和服务器承载能力而定，并且留有一定余量。</li><li>一个合理的ES 集群配置应该不少于5台节点，3台Master节点，避免脑裂时无法选举出新的master节点的情况，另外可能还需要其他一些单独的节点，比如ELK系统中的kibana、Logstash,ES 节点不要部署其他任何东西除了beats。</li></ol></li><li><p>集群搭建：</p><ol><li>重要节点的配置：<ul><li>cluster.name: 集群的名字</li><li>node.name:节点名字</li><li>path.data:默认数据的存储位置，不修改，ES_PATH/data,推荐设置到安装目录之外  /var/log</li><li>path.logs: 如 /var/log/elasticsearch ,别忘了改目录权限（读写）</li><li>bootstrap.memory.lock:内存锁，生产环境一般无脑设成true,禁用swap空间，如果内存不足的是否，ES会使用Swap空间，性能是非常差。内存小的话，引导检查过不去。</li><li>network.host:当前节点绑定IP地址</li><li>http.port:服务端口号，用来 REST api 服务用的。[9200-9299）</li><li>transport.port ：集群中多个节点通信的端口号。节点转发通讯端口[9300-9399)</li><li>discovery.send_hosts: [“localhost:9200”,”localhost:9201”] 候选节点的IP地址，当前master节点和候选节点的IP地址。</li><li>cluster.initial_master_nodes: 集群初始化的时候，手动配置一个master节点，可以是IP地址，也可以是节点名称。</li><li>http.cors.enabled:true</li><li>http.cors.allow-origin:跳板机的地址</li><li>node.master:true 是否是候选节点 </li><li>node.data:false 是否是数据节点</li></ul></li><li>其他配置（默认是比较合理的，最好不要改的配置）（不充分了解，最好不要改）<ul><li>比如 max_result_window:10000 默认每一页最多10000条数据，为了限制内存的开销。<br>deep paging 解决方案=&gt;1.scoll;2.search-after；ES 没有银弹的，不可能通过修改一向，或者几项配置一下子提升性能的。</li></ul></li><li>JVM：<ul><li>jvm heap默认配置：7.6.2版本默认1GB，这个值是比较小的。</li><li>jvm heap 大小不要超过物理内存的50%，即便你的物理内存特别大，你的堆内存heap最大也不要超过34GB-2GB, 16GB-64GB（compressed OOP）,物理内存32G 16G fielddata 分页 大量使用堆内存，ES基于Lucene，它依赖os cache。</li></ul></li><li>如何修改堆内存 <ul><li>ES启动时 ES_JAVA_OPTS=”-Xms4g-Xmx4g” ./bin/elasticsearch</li><li>jvm.options</li><li>ES_HEAP_SIZE: 环境变量</li><li></li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.集群优化（运维优化）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;节点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相同角色节点，避免使用较大差异的配置&lt;/li&gt;
&lt;li&gt;避免使用 “超大杯”服务器（SS服务器：Super Server）,128核心，1T的内存，2T的硬盘。不仅会赵成资源浪费，而且</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>es-scripting-search</title>
    <link href="https://wulianling.github.io/2021/11/07/es-scripting-search/"/>
    <id>https://wulianling.github.io/2021/11/07/es-scripting-search/</id>
    <published>2021-11-07T13:00:07.000Z</published>
    <updated>2021-11-07T15:55:35.672Z</updated>
    
    <content type="html"><![CDATA[<h4 id="painless"><a href="#painless" class="headerlink" title="painless"></a>painless</h4><p>ES 默认的脚本语言，</p><ol><li>Groovy: 1.4.X-5.0</li><li>Painless:用于内联和</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;source&quot;:&quot;ctx._source.price-&#x3D;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;: &quot;ctx._source.price-&#x3D;1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># tag 无线充电</span><br><span class="line"></span><br><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;：&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;ctx._source.tags.add(&#39;无线充电&#39;)&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 传参</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;：&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;ctx._source.tags.add(params.tag_name)&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;tag_name&quot;:&quot;无线充电&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line"></span><br><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;：&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;ctx.op&#x3D;&#39;delete&#39;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#新增（存在更新，不存在创建） upsert</span><br><span class="line"></span><br><span class="line">POST &#x2F;product2&#x2F;_update&#x2F;4</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;：&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;ctx._source.taggs.add(params.tag_name)&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;tag_name&quot;:&quot;无线充电&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;upsert&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;小米10&quot;，</span><br><span class="line">&quot;price&quot;:19999</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#Painless espression(支持的范围小 某些场景下性能更好)</span><br><span class="line">#mustache java</span><br><span class="line"></span><br><span class="line">GET product2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;test_field&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;scrpit&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;expression&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;]*0.9&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET product2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;test_field&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;scrpit&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;expression&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;]*0.9&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET product2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;test_field&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;].value*params.discount&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;discount&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>用参数的好处，下次更改参数，不会再次编译，取缓存的算式，提高二次查询的效率，缓存大小有限制，100M</em><br><em>编译行为，每分钟15次</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">GET product2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;].value&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;test_field&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;[doc[&#39;price&#39;].value*params.discount_9&quot;,&quot;doc[&#39;price&#39;].value*params.discount_8&quot;,&quot;doc[&#39;price&#39;].value*params.discount_7]&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;discount_9&quot;:0.9,</span><br><span class="line">&quot;discount_8&quot;:0.8,</span><br><span class="line">&quot;discount_7&quot;:0.7,</span><br><span class="line">&quot;discount_6&quot;:0.6,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Stored script</span><br><span class="line"># &#x2F;_script&#x2F;&#123;id&#125;</span><br><span class="line">POST _scripts&#x2F;caclculate-discount</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;].value*params.discount&quot;,</span><br><span class="line">&quot;params&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET product2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;doc[&#39;price&#39;].value&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;test_field&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:&quot;caclculate-discount&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;discount&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Dates</span><br><span class="line"></span><br><span class="line">GET product&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;script_fields&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;test_year&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;source&quot;: &quot;doc.createtime.value.year&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#Groovy file:&quot;test.groovy&quot;</span><br><span class="line"></span><br><span class="line">POST product2&#x2F;_update&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">ctx._source.name+&#x3D;params.name;</span><br><span class="line">ctx._source.price++params.discount</span><br><span class="line">&quot;&quot;&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;test&quot;,</span><br><span class="line">&quot;discount&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#正则部分匹配</span><br><span class="line">POST product2&#x2F;_update&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">if(ctx._source.name&#x3D;~ &#x2F;[\s\S]*phone[\s\S]*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">ctx._source.name +&#x3D; &quot;***matched&quot;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">ctx.op&#x3D;&quot;noop&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;test&quot;,</span><br><span class="line">&quot;discount&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#正则完全匹配</span><br><span class="line">POST product2&#x2F;_update&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">if(ctx._source.createtime &#x3D;&#x3D;~ &#x2F;[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">ctx._source.name +&#x3D; &quot;***matched&quot;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">ctx.op&#x3D;&quot;noop&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;,</span><br><span class="line">&quot;params&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;test&quot;,</span><br><span class="line">&quot;discount&quot;:0.9</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 聚合</span><br><span class="line"></span><br><span class="line">GET product&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;bool&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;filter&quot;:</span><br><span class="line">[</span><br><span class="line">&quot;range&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lt&quot;:1000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;aggs&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;tset_sum&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;sum&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;script&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;lang&quot;:&quot;paimless&quot;,</span><br><span class="line">&quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">int total&#x3D;0;</span><br><span class="line">for(int i&#x3D;0;i&lt;doc[&#39;tags.keyword&#39;].length;i++)&#123;</span><br><span class="line">total++;</span><br><span class="line">&#125;;</span><br><span class="line">return total;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>doc[‘filed_name’] =&gt;params[‘_source’][‘field_name’]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;painless&quot;&gt;&lt;a href=&quot;#painless&quot; class=&quot;headerlink&quot; title=&quot;painless&quot;&gt;&lt;/a&gt;painless&lt;/h4&gt;&lt;p&gt;ES 默认的脚本语言，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Groovy: 1.4.X-5.0&lt;/li</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>es底层原理</title>
    <link href="https://wulianling.github.io/2021/11/06/es-underlying-principle/"/>
    <id>https://wulianling.github.io/2021/11/06/es-underlying-principle/</id>
    <published>2021-11-06T13:24:27.000Z</published>
    <updated>2021-11-06T15:03:14.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正排索引（doc-values）-和倒排索引"><a href="#正排索引（doc-values）-和倒排索引" class="headerlink" title="正排索引（doc values） 和倒排索引"></a>正排索引（doc values） 和倒排索引</h4><ol><li>概念： 从广义来说，doc 是掠视本质上是一个序列化的列式存储。列式存储适用于聚合、排序、脚本等操作，所有的数字、地理坐标、日期、IP、和不分析字段类型都会默认开启。</li><li>特点： 倒排索引的优势在于查找包含某个项的文档，相反，如果用它确定哪些项是否存在单个文档里，性能较差。</li><li>优化： es官方建议，es大量是基于os cache来进行缓存和提升性能的，不建议jvm内存来进行缓存，那样会导致一定的gc开销和oom问题，给jvm更小的内存，给os cache更大的内存。比如64G服务器，给jvm最多16G， os cache 可以提升doc values和倒排索引的缓存和查询效率。</li></ol><p>倒排索引 ： 字段分词，（key）词项-哪些doc，词项表<br>正排索引 ： (key)doc_id-字段词项<br><img src="/2021/11/06/es-underlying-principle/Inverted-index.png"></p><ol><li><p>倒排索引和正排索引都是在index-time（索引创建）的时候创建，都会缓存在内存中，前提是内存足够。<br>keyword 为聚合而生，正排索引；type 倒排索引；</p></li><li><p>不分词的field会在index-time时生成正排索引，聚合时直接使用正排索引，而分词的field在创建索引时是没有正排索引的，如果没有创建doc values 的字段需要做聚合查询，name需要将fileddata打开，设置为true。</p></li><li><p>doc value 使用非jvm内存，gc友好。</p></li></ol><p><em>fielddata 默认false，慎用</em><br><em>确定不使用聚合查询 doc_values 设置为false，确定只是用聚合分析 index 设置为false</em></p><p><img src="/2021/11/06/es-underlying-principle/doc_values-fielddata.png"></p><h4 id="基于mget批量查询以及基于bulk的批量增删改"><a href="#基于mget批量查询以及基于bulk的批量增删改" class="headerlink" title="基于mget批量查询以及基于bulk的批量增删改"></a>基于mget批量查询以及基于bulk的批量增删改</h4><ol><li><p>mget：批量查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_mget</span><br><span class="line">&#123;</span><br><span class="line">&quot;docs&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;:&quot;prodect&quot;,</span><br><span class="line">&quot;_id&quot;:1</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;:&quot;prodect&quot;,</span><br><span class="line">&quot;_id&quot;:2</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> GET &#x2F;prodect&#x2F;_mget</span><br><span class="line">&#123;</span><br><span class="line">&quot;docs&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot;:1</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot;:2</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET &#x2F;prodect&#x2F;_mget</span><br><span class="line">&#123;</span><br><span class="line">&quot;ids&quot;:[1,2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#source</span><br><span class="line"></span><br><span class="line">GET &#x2F;product&#x2F;_mget</span><br><span class="line">&#123;</span><br><span class="line">&quot;docs&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot;:1,</span><br><span class="line">&quot;_source&quot;:false</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot;:2,</span><br><span class="line">&quot;_source&quot;:</span><br><span class="line">[</span><br><span class="line">&quot;name&quot;,&quot;price&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> GET &#x2F;product&#x2F;_mget</span><br><span class="line">&#123;</span><br><span class="line">&quot;docs&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot;:2,</span><br><span class="line">&quot;_source&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;include&quot;:[&quot;name&quot;],</span><br><span class="line">&quot;exclude&quot;:[&quot;name&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>bulk: 批量增删改 no-query</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;_bulk</span><br><span class="line"></span><br><span class="line">POST&#x2F;index&#x2F;_bulk</span><br><span class="line">&#123;&quot;action&quot;:&#123;&quot;metedata&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;data&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>Operate：</li></ul><ol><li>create: PUT /index/_create/id/. 强制创建（是否制定id）</li><li>delete: lazy delete原理</li><li>index: 可以是创建，也可以是全量替换</li><li>update: partial update(全量替换 部分替换)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;bulk?filter_path&#x3D;items.*.error # 返回的结果只包含错误的结果</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;index&quot;:&quot;product&quot;,&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;_buld create1&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;index&quot;:&quot;product&quot;,&quot;_id&quot;:11&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;_buld create11&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">POST &#x2F;bulk</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;index&quot;:&quot;product&quot;,&quot;_id&quot;:11,&quot;retry_on_conflict&quot;:&quot;3&quot;&#125;&#125;#当并发冲突时，尝试3次</span><br><span class="line">&#123;&quot;name&quot;:&quot;_buld create11&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">POST &#x2F;bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;index&quot;:&quot;product&quot;,&quot;_id&quot;:11,&quot;retry_on_conflict&quot;:&quot;3&quot;&#125;&#125;#当并发冲突时，尝试3次</span><br><span class="line">&#123;&quot;name&quot;:&quot;_buld create11&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="ES并发冲突问题（悲观锁和乐观锁）"><a href="#ES并发冲突问题（悲观锁和乐观锁）" class="headerlink" title="ES并发冲突问题（悲观锁和乐观锁）"></a>ES并发冲突问题（悲观锁和乐观锁）</h4><ol><li><p>悲观锁：各种情况都加锁，读写锁、行级锁、表级锁、使用简单，但是并发能力差</p></li><li><p>乐观锁：并发能力高，操作麻烦，每次no-query操作都需要对比version（ES 使用乐观锁）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;正排索引（doc-values）-和倒排索引&quot;&gt;&lt;a href=&quot;#正排索引（doc-values）-和倒排索引&quot; class=&quot;headerlink&quot; title=&quot;正排索引（doc values） 和倒排索引&quot;&gt;&lt;/a&gt;正排索引（doc values） 和倒排</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>上机实操：ES查询语法</title>
    <link href="https://wulianling.github.io/2021/11/02/es_query_syntax/"/>
    <id>https://wulianling.github.io/2021/11/02/es_query_syntax/</id>
    <published>2021-11-02T12:28:46.000Z</published>
    <updated>2021-11-06T13:42:08.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="es查询语法"><a href="#es查询语法" class="headerlink" title="es查询语法"></a>es查询语法</h3><h4 id="Searchtimeout"><a href="#Searchtimeout" class="headerlink" title="Searchtimeout"></a>Searchtimeout</h4><ol><li><p>默认没有timeout，如果设置了timeout，name会执行timeout机制。</p></li><li><p>timeout机制：假设用户查询结果有1W条数据，但是需要10s才能查询完毕，但是用户设置了1s的timeout，name不管当前以供查询到了多少数据，都会在1s后ES将停止查询，并返回当前数据。</p></li></ol><h4 id="ES查询"><a href="#ES查询" class="headerlink" title="ES查询"></a>ES查询</h4><ol><li>queryString查询<br>类似URL传参的形式</li></ol><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_doc&#x2F;_search?q&#x3D;name:xiaomi(有相关度分数_score)</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search?from&#x3D;0&amp;size&#x3D;2&amp;sort&#x3D;price:asc(无相关度分数_score)</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search?from&#x3D;0&amp;size&#x3D;20</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tips:</p><blockquote><p>types removal specifying types in search requests is deprecated<br>7.X 还能用， 8.X已删除</p></blockquote><p>为什么加了排序，没有相关度分数？<br>答：默认按照_score 排序，如果使用了sort 这个时候_score：null</p><ol start="2"><li>query DSL</li></ol><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查询全部 match_all</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;natch_all&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;匹配查询 match</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaomi&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 排序 sort</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaomi&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;sort&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:&quot;desc&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;多字段匹配 multiples match</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;multi_match&quot;:&#123;</span><br><span class="line">&quot;query&quot;: &quot;xiaomi&quot;,</span><br><span class="line">&quot;fields&quot;:[&quot;name&quot;,&quot;desc&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;sort&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:&quot;desc&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;_source 元数据（指定字段）</span><br><span class="line">GET &#x2F;index&#x2F;_search&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaomi&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;_source&quot;:[&quot;name&quot;,&quot;price&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;deep-paging分页</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;natch_all&quot;:&#123;&#125;</span><br><span class="line">&#125;，</span><br><span class="line">&quot;from&quot;:0,</span><br><span class="line">&quot;size&quot;:20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>Full-text queries 全文检索<ol><li>query-term:不会被分词<br> 关键词作为一个完整的词，进行匹配查询</li><li>match 和 term<ul><li>match 的关键词会被分词后进行匹配查询，</li><li>term 的 关键词不会被分词，进行匹配查询</li></ul></li><li><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">全文检索</span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaomi&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># term 关键词 不分词</span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line">&#123;&quot;term&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;,</span><br><span class="line">&#123;&quot;term&quot;:&#123;&quot;name&quot;:&quot;phone&quot;&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># name in(&quot;xiaomi&quot;, &quot;phone&quot;)</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;terms&quot;:&#123;</span><br><span class="line">&quot;name&quot;:[&quot;xiaomi&quot;,&quot;phone&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 默认分词器</span><br><span class="line"></span><br><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">&quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">&quot;test&quot;:&quot;xiaomi nfc phone&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><em>GET  和 POST 也能查</em></p><ol start="4"><li>短语搜索</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_phrase&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaomi phone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>query and filter 查询和过滤<ol><li>bool: 可以组合多个查询条件，bool查询也是采用more_matches_is_batter的机制，因此满足must和should的字句的文档将会合并起来计算分值。<ol><li>must:必须满足</li><li>filter：过滤器 不计算相关度分数的(性能比must高)，<strong>支持缓存</strong></li><li>should: 可能满足 or</li><li>must_not:必须不满足 不计算相关度分数的</li><li>minimum_should_match: 默认 1  ，配置should 里面必须匹配的条件数量</li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;,</span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;shouji&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;filter&quot;:[</span><br><span class="line">&#123;&quot;match_phrase&quot;:&#123;&quot;naem&quot;:&quot;xiaomi&quot;&#125;&#125;,</span><br><span class="line">&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:1999&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;must_not&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;should&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;filter&quot;:[</span><br><span class="line">&#123;&quot;rang&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:4999&#125;&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># filter 单独查询，结果不排序</span><br><span class="line"></span><br><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;constant_score&quot;:&#123;</span><br><span class="line">&quot;filter&quot;:[</span><br><span class="line">&#123;&quot;rang&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:4999&#125;&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>嵌套查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">#去除相关度查询</span><br><span class="line">&quot;constant_score&quot;:&#123;</span><br><span class="line">&quot;filter&quot;:[</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;must_not&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;should&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;xiaomi&quot;&#125;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;filter&quot;:[</span><br><span class="line">&#123;&quot;rang&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:4999&#125;&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>高亮查询<br>匹配到的结果 高亮返回</li></ol><h4 id="Deep-paging-问题"><a href="#Deep-paging-问题" class="headerlink" title="Deep paging 问题"></a>Deep paging 问题</h4><p>size 500<br>index 11<br>如： 用户查询 50条 价格 由低到高的数据</p><p>数据在不同保证的分片上。5个分片<br>每个分片 1W</p><p>都去取 5050 全部拿出来，进行排序，在去取，排完序后取50条数据</p><ul><li>数据大于1W ，不要使用</li><li>返回数据数量不要大于1W</li></ul><p>解决方法：</p><ol><li>尽量避免</li><li>使用scroll search </li></ol><h3 id="scroll-search"><a href="#scroll-search" class="headerlink" title="scroll search"></a>scroll search</h3><p>scroll 游标<br>1m 开窗期：1分钟时间到了，就不能查询了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search?scroll&#x3D;1m</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;sort&quot;:[&#123;&quot;price&quot;:&quot;asc&quot;],</span><br><span class="line">&quot;size&quot;:2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回 scroll_id 标记 最后查询的位置</p><p>下一次查询，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search&#x2F;scroll</span><br><span class="line">&#123;</span><br><span class="line">&quot;scroll&quot;:1m # 第二次查询的时候更新这个到期时间</span><br><span class="line">&quot;scroll_id&quot; :&quot;SD9SU92398HR29SHH929X7&quot; #每一次查询必须带上前一次的ID</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filter-缓存"><a href="#filter-缓存" class="headerlink" title="filter 缓存"></a>filter 缓存</h3><ol><li>filter不是每次执行否会进行缓存，而是当执行一定次数的时候才会进行cache一个二进制数组，1表示匹配，2表示不匹配，这个次数是不固定的。</li><li>filter会从有限过滤掉稀疏的数据中，保留匹配的cache数组。</li><li>filter cache 保存的是匹配的结果，不需要再从倒排索引中去查找比对，大大涂改可查询速度，</li><li>filter <strong>一般会在query之前执行</strong>，过滤掉一部分数据，从而提高query的速度</li><li>filter不计算相关度分数，在执行效率上比query高。</li><li><strong>当元数据发生改变时，cache也会更新。</strong></li></ol><p><em>filter没有匹配度查询</em></p><h3 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h3><p>概念：mapping 就是ES数据字段field的type元数据，ES在创建索引的时候,dynamic mapping会自动为不同的数据指定相应mapping，mapping中包含了字段的类型、搜索方式（exact value或者full text）、分词器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;index&#x2F;_doc&#x2F;100</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;product&#x2F;_mapping&#x2F;type（旧）</span><br><span class="line">GET &#x2F;product&#x2F;_mapping*s*（新）</span><br></pre></td></tr></table></figure><p>如果 字段属性 类型是text ，会默认keyword 的type是keyword 关键词长度是256后忽视</p><ol><li><p>Dynamic mapping </p><ol><li>“Elasticsearch” : text/keyword</li><li>123456 =&gt; long ? 为啥不是integer</li><li>123.123 =&gt; double</li><li>true =&gt; boolean</li><li>2020-05-30 =&gt; date<br>为啥price是long类型而不是integer类型，因为es的mapping_type 是由json分析器检测数据类型，而json没有隐式类型转换（integer=&gt;long or float =&gt; double）,所以dynamic mapping 会选择比较宽的数据类型</li></ol></li><li><p>搜索方式</p><ol><li>exact value 精确匹配： 在倒排索引过程中，分词器会将field作为一个整体创建到索引中，</li></ol><p> <em>注短语搜索：关键词作为整体匹配</em></p><ol start="2"><li><p>full text 全文索引： 分词、近义词同义词、混淆词、大小写、过滤、时态转换等（normalzition）</p><p>exact value 类型字段 必须完全匹配 如：date 类型<br>string 的 text 是 full text，keyword 是 exact value</p></li></ol></li><li><p>ES 数据类型</p><ol><li>核心类型<ol><li>数字类型<ul><li>long/integer/short/byte/float/half_foat/scaled_float</li></ul></li><li>字符串：string<ul><li>keyword: 适用于索引结构化的字段，可以用于过滤、排序、聚合。keyword类型的字段只能通过精确值（exact value） 搜索到。如id应该用keyword</li><li>text： 当一个字段是要被全恩搜索的，比如email内容、产品描述，这些字段应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排序索引以前，字符串会被分析器分恒一个一个词项。text类型的字段不用于排序，<strong>很少用于聚合</strong>。</li><li>有时，在同一个字段汇总同时具有全文和关键词版本会很有用，一个用于全文本搜索，另一个用于聚合和排序。</li></ul></li><li>date</li><li>布尔类型</li><li>binary:二进制</li><li>range（区间类型）：integer_range/float_range/long_range/double_range/date_range</li><li>复杂类型<ol><li>object：用于单个JSON字符串</li><li>Nested: 用于JSON字符串数组</li></ol></li><li>地理位置</li><li>特有类型<ol><li>Array</li><li></li></ol></li></ol></li></ol></li><li><p>创建mapping</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;index</span><br><span class="line">&#123;</span><br><span class="line">&quot;mappings&quot;:&#123;</span><br><span class="line">&quot;properties&quot;:&#123;</span><br><span class="line">&quot;create_date&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;date&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>索引、名字、字段 一律小写</strong></p><ol start="5"><li>mapping parameters<ol><li>index:是否创建对当前字段创建索引，默认 true,如果不创建索引，该字段不会被通过这个字段检索数据。</li><li>analyzer: 指定分析器（character filter、tokenizer、Token filter）</li><li>coerce： 是否允许被强制类型转换</li><li>bost:权重 默认1，权重</li><li>copy_to: </li><li><strong>doc_value</strong>:为了提高排序和聚合效率，默认true。如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，呢可以禁用doc值一节省磁盘空间（不支持text和annotated_text）,如果不需要聚合查询，可以设置为false，提高查询效率，如果设置成false，不能再改了， 如果想改，只能重新创建索引。</li><li>dynamic: 控制是否可以动态添加新字段<ol><li>true新检测到的字段将添加到映射中。（默认）</li><li>false 新检测到的字段将被忽略，这些字段将不会被索引，因此将无法搜索，单人会出现在_source返回的匹配相中，这些字段不会添加到映射总，必须显示添加新字段。</li><li>strict如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显示添加到映射中。</li></ol></li><li>eager_global_ordinals： 用于集合的字段上，优化聚合性能。</li><li>enable：是否创建倒排索引，可以对字段操作。</li><li><strong>fielddate</strong>:查询是内存数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，需要字段为fielddata数据结构，并且创建正排索引保存到堆中。</li><li>fields: 给filed创建多个字段，用于不同目的（全文检索或聚合分析排序）</li><li>format: 格式化 如果date 的格式化</li><li>norms: 是否禁用评分（filter和聚合字段上应该禁用）</li><li>null_value: 为null 设置默认值</li><li>search_analyzer： 单独设置查询时分析器</li><li>similarity: 相关度算法。</li><li>…(其他看官网)</li></ol></li></ol><h3 id="聚合搜索"><a href="#聚合搜索" class="headerlink" title="聚合搜索"></a>聚合搜索</h3><ol><li>bucket 和 metirc</li><li>语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aggs:&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>“group by”:<br>{</li></ol><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;&#125;，</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">#聚合查询的名字，自定义</span><br><span class="line">&quot;name&quot;:&#123;</span><br><span class="line">&quot;terms&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;tags.keyword&quot; #test类型本身不支持聚合,推荐用 keyword聚合 ，（mapping 的 fielddata性能低）</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;，</span><br><span class="line">&quot;size&quot;:0 #只显示聚合查询结果</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>avg</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;avg&quot;：&#123;</span><br><span class="line">&quot;terms&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;tags.keyword&quot;,</span><br><span class="line">&quot;order&quot;:&#123;</span><br><span class="line">&quot;_term&quot;:&quot;asc&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;avg_price&quot;:&#123;</span><br><span class="line">&quot;avg&quot;:&#123;</span><br><span class="line">&quot;filed&quot;:&quot;price&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">size:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>分组查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;tag_agg_grup&quot;：&#123;</span><br><span class="line">&quot;range&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;price&quot;,</span><br><span class="line">&quot;ranges&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">&quot;from&quot;: 100,</span><br><span class="line">&quot;to&quot;:1000</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;from&quot;: 2000,</span><br><span class="line">&quot;to&quot;:3000</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;from&quot;: 3000,</span><br><span class="line">&quot;to&quot;:4000</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;price_agg&quot;:&#123;</span><br><span class="line">&quot;avg&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;price&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">size:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;es查询语法&quot;&gt;&lt;a href=&quot;#es查询语法&quot; class=&quot;headerlink&quot; title=&quot;es查询语法&quot;&gt;&lt;/a&gt;es查询语法&lt;/h3&gt;&lt;h4 id=&quot;Searchtimeout&quot;&gt;&lt;a href=&quot;#Searchtimeout&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>ES安装、健康检查</title>
    <link href="https://wulianling.github.io/2021/11/01/es-installation2/"/>
    <id>https://wulianling.github.io/2021/11/01/es-installation2/</id>
    <published>2021-11-01T13:10:33.000Z</published>
    <updated>2021-11-02T12:27:56.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>JDK-&gt;下载-&gt;<br>启动 Linux:./elasticsearch -d window: elasticsearch-&gt;<br>验证: localhost:9200</p><h4 id="开发模式和生产模式"><a href="#开发模式和生产模式" class="headerlink" title="开发模式和生产模式"></a>开发模式和生产模式</h4><ol><li>生产模式<br>如果修改有关集群的相关配置，ES 就认为你用于生产环境，触发生产检查， 警告信息升级到异常，log输出，阻断启动.</li><li>开发模式<br>默认配置，用于学习阶段</li></ol><p>学习阶段 可以在docker安装，生产环境，不建议安装到容器中。 </p><ol start="3"><li>kibana<br>localhost:6501</li></ol><p>  node.data = true : 设置成数据节点  ，master 不要设置，master 尽量只用来</p><h3 id="master-选举"><a href="#master-选举" class="headerlink" title="master 选举"></a>master 选举</h3><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>节点互不通信， 发生选举 ，导致出现两个master </p><p>解决方法： discovery.zen.minimum_master_nodes =N/2+1</p><p>3或4个节点 ，可以容忍1各节点宕机</p><p>如果2个或更少，集群必须保持可用，不可以忍受宕机，不然会发生脑裂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;JDK-&amp;gt;下载-&amp;gt;&lt;br&gt;启动 Linux:./elasticsearch -d window: elasticsearch-&amp;</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMq helloWorld</title>
    <link href="https://wulianling.github.io/2021/10/20/rabbitmq-helloworld/"/>
    <id>https://wulianling.github.io/2021/10/20/rabbitmq-helloworld/</id>
    <published>2021-10-20T14:40:27.000Z</published>
    <updated>2021-10-27T13:06:12.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><ol><li><p>一个mq服务可以设置多个虚拟机，每个虚拟机就像阿当予一个独立的mq.</p><h4 id="build-by-maven"><a href="#build-by-maven" class="headerlink" title="build by maven"></a>build by maven</h4></li><li><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;last-version&#125;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过连接工厂穿件新的连接和mq建立连接</span><br><span class="line">      ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();</span><br><span class="line">      connectionFactory.setHost(&quot;127.0.0.1&quot;);</span><br><span class="line">      connectionFactory.setPort(5672);</span><br><span class="line">      connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">      connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">      &#x2F;&#x2F;设置虚拟机,一个mq的服务可以设置多个虚拟机，每一个虚拟机就相当于一个独立的mq</span><br><span class="line">      connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);</span><br><span class="line">      &#x2F;&#x2F;建立新连接</span><br><span class="line">      Connection connection &#x3D; null;</span><br><span class="line">      Channel channel &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          connection &#x3D; connectionFactory.newConnection();</span><br><span class="line">          &#x2F;&#x2F;设置会话通道,生产者和mq服务所有通信都在channel通道中完成。</span><br><span class="line">          channel &#x3D; connection.createChannel();</span><br><span class="line">          &#x2F;&#x2F;声明队列，如果队列在mq中没有则要创建</span><br><span class="line">          &#x2F;&#x2F;String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span><br><span class="line">          &#x2F;**</span><br><span class="line">           * 1.queue 队列名称</span><br><span class="line">           * 2.durable 是否持久化，如果持久化，mq重启队列还在</span><br><span class="line">           * 3.exclusive 是否独占连接， 队列只允许在该连接中访问，如果connection连接关闭队列自动删除， 如果将此参数设置true可用于临时队列的创建。</span><br><span class="line">           * 4.autoDelete 自动删除，对了不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span><br><span class="line">           * 5.argument是参数，可以设置一个队列的扩展参数，（如存活时间）</span><br><span class="line">           *&#x2F;</span><br><span class="line">          channel.queueDeclare(QUEUE, true, false, false ,null);</span><br><span class="line">          &#x2F;&#x2F;发送消息</span><br><span class="line">          &#x2F;&#x2F;String exchange, String routingKey, BasicProperties props, byte[] body)</span><br><span class="line">          &#x2F;**</span><br><span class="line">           * 1. exchange, 交换机，如果不指定将使用mq默认的交换机（设置为“”）</span><br><span class="line">           * 2. routingKey， 路由key，交换机Kenji路由key来讲消息转发到指定的队列，如果使用默认交换机，routingKey这是为队列的名称。</span><br><span class="line">           * 3. props 消息属性</span><br><span class="line">           * 4.body 消息内容</span><br><span class="line">           *&#x2F;</span><br><span class="line">          String message &#x3D; &quot;helloWorld !!!!&quot;;</span><br><span class="line">          channel.basicPublish(&quot;&quot;, QUEUE, null, message.getBytes());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; catch (TimeoutException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;finally &#123;</span><br><span class="line">          &#x2F;&#x2F;关闭连接</span><br><span class="line">          &#x2F;&#x2F;先关闭通道</span><br><span class="line">          try &#123;</span><br><span class="line">              channel.close();</span><br><span class="line"></span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; catch (TimeoutException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              connection.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>consumer</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过连接工厂穿件新的连接和mq建立连接</span><br><span class="line">     ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();</span><br><span class="line">     connectionFactory.setHost(&quot;127.0.0.1&quot;);</span><br><span class="line">     connectionFactory.setPort(5672);</span><br><span class="line">     connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">     connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">     &#x2F;&#x2F;设置虚拟机,一个mq的服务可以设置多个虚拟机，每一个虚拟机就相当于一个独立的mq</span><br><span class="line">     connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);</span><br><span class="line">     &#x2F;&#x2F;建立新连接</span><br><span class="line">     try &#123;</span><br><span class="line">         Connection connection &#x3D; connectionFactory.newConnection();</span><br><span class="line">         &#x2F;&#x2F;设置会话通道,生产者和mq服务所有通信都在channel通道中完成。</span><br><span class="line">         Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;声明队列，如果队列在mq中没有则要创建</span><br><span class="line">         &#x2F;&#x2F;String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span><br><span class="line">         &#x2F;**</span><br><span class="line">          * 1.queue 队列名称</span><br><span class="line">          * 2.durable 是否持久化，如果持久化，mq重启队列还在</span><br><span class="line">          * 3.exclusive 是否独占连接， 队列只允许在该连接中访问，如果connection连接关闭队列自动删除， 如果将此参数设置true可用于临时队列的创建。</span><br><span class="line">          * 4.autoDelete 自动删除，对了不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span><br><span class="line">          * 5.argument是参数，可以设置一个队列的扩展参数，（如存活时间）</span><br><span class="line">          *&#x2F;</span><br><span class="line">         channel.queueDeclare(QUEUE, true, false, false ,null);</span><br><span class="line">         DefaultConsumer defaultConsumer &#x3D; new DefaultConsumer(channel)&#123;</span><br><span class="line">             &#x2F;**</span><br><span class="line">              * 当接收到消息时，此方法被调用。</span><br><span class="line">              * @param consumerTag 消费者标签，用来标识消费者， 在监听队列式设置channel。basicConsumer</span><br><span class="line">              * @param envelope 信封，通过envelope</span><br><span class="line">              * @param properties</span><br><span class="line">              * @param &lt;body&gt;&lt;&#x2F;body&gt;</span><br><span class="line">              * @throws IOException</span><br><span class="line">              *&#x2F;</span><br><span class="line">             @Override</span><br><span class="line">             public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                 &#x2F;&#x2F;交换机</span><br><span class="line">                 String exchange &#x3D; envelope.getExchange();</span><br><span class="line">                 &#x2F;&#x2F;消息id，mq在channel用来标识消费的id，可用于确认消息已接收。</span><br><span class="line">                 long deliveryTag &#x3D; envelope.getDeliveryTag();</span><br><span class="line">                 &#x2F;&#x2F;消息的属性</span><br><span class="line">                 String message &#x3D; new String(body, &quot;utf-8&quot;);</span><br><span class="line">                 System.out.println(&quot;receive message:&quot;+ message);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;监听队列</span><br><span class="line">         &#x2F;&#x2F;String queue, boolean autoAck, Consumer callback</span><br><span class="line">         &#x2F;**</span><br><span class="line">          * 1. queue 队列名称</span><br><span class="line">          * 2.autoAck 自动回复，当消费者接收到消息后要告诉mq消息已收到，如果将此参数设置为true表示会自动回复mq，如果设置为false要通过编程实现回复。</span><br><span class="line">          * 3.callback，消费方法，当消费者接收到消息要执行的方法。</span><br><span class="line">          *&#x2F;</span><br><span class="line">        channel.basicConsume(QUEUE, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; catch (TimeoutException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><p>一个生产者 &gt; 个队列 &gt; 一个消费者</p><h3 id="work-queues-工作队列模式"><a href="#work-queues-工作队列模式" class="headerlink" title="work queues 工作队列模式"></a>work queues 工作队列模式</h3><ol><li>和helloworld 的区别是 一个队列有多个消费者，但是 消息不会被重复消费，轮询的方式将消息平均发送给消费者。</li></ol><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>生产者 &gt; 交换机 &gt; 各个队列 &gt; 每个队列有不同消费者<br> 一个消息一下子被多个消费者接收到。</p><p> 不同点：</p><ol><li>type = FANOUT</li><li>交换机将消息发送到所有绑定了的队列中，所有队列 默认一个相同的 routingKey</li></ol><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>和发布订阅模式相比，交换机可以根据路由key，将消息发送到指定的队列</p><p>不同点：</p><ol><li>type = direct</li><li>queue  绑定自定义 routingKey</li></ol><h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p>不同点：</p><ol><li><p>type = topic </p></li><li><p>routingKey 通配符匹配  即可配对成功</p><p>“#”:匹配一个或多个词，比如inform。# 可匹配 inform.sms、inform.email、inform.emal.sms<br>“<em>“: 只能匹配一个词， 比如inform.</em>, 可以匹配inform.sms、 inform.email</p></li></ol><h3 id="Header模式"><a href="#Header模式" class="headerlink" title="Header模式"></a>Header模式</h3><p>不同点：</p><ol><li>取消了routingKey, 使用header中的key/value匹配队列</li></ol><h3 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h3><ol><li>客户端 发送执行方法的消息 到一个队列。</li><li>务端消费这个消息，执行对应方法，把执行完的结果放在另一个队列中。</li><li>客户端监听这个执行结果队列，拿到对应队列的结果消息 执行后面自己的业务逻辑。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HelloWorld&quot;&gt;&lt;a href=&quot;#HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;HelloWorld&quot;&gt;&lt;/a&gt;HelloWorld&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个mq服务可以设置多个虚拟机，每个虚拟机就像阿当予一个独</summary>
      
    
    
    
    
    <category term="mq" scheme="https://wulianling.github.io/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>ES安装、健康检查</title>
    <link href="https://wulianling.github.io/2021/10/19/es-installation/"/>
    <id>https://wulianling.github.io/2021/10/19/es-installation/</id>
    <published>2021-10-19T14:53:18.000Z</published>
    <updated>2021-10-19T14:53:21.598Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES-和-Kibana-安装"><a href="#ES-和-Kibana-安装" class="headerlink" title="ES 和 Kibana 安装"></a>ES 和 Kibana 安装</h3><ol><li>修改了集群默认配置 就会认为是生产环境，会触发一个检查机制，引导检查</li><li>生产环境 多个node不会在同台机器启动！</li></ol><h3 id="ES-node"><a href="#ES-node" class="headerlink" title="ES-node"></a>ES-node</h3><ol><li><p>Role</p><ol><li>master：主节点</li><li>voting：仅投票 （也可以作为数据节点）</li><li>coordinating： 仅协调</li></ol></li><li><p>node-type:</p><ol><li>master-eligibale node (候选节点)</li><li>data node（数据节点）</li><li>ingest node </li><li>machine learning node(机器学习节点)</li></ol></li></ol><ol><li>node.master:true //设置主节点，可以竞选主节点 false :没有竞选主节点的资格</li><li>node.data:true //可以进行数据存储</li><li>node.voing_only:true //仅投票</li></ol><p>一般主节点不进行数据存储，只负责 查询，新增，保持高性能</p><p>两个都是false: 协调节点：不作为数据存储 ，只做转发。</p><h3 id="集群的健康值检查"><a href="#集群的健康值检查" class="headerlink" title="集群的健康值检查"></a>集群的健康值检查</h3><ol><li>green: 所有P shared 和R shared 均为active，集群健康。</li><li>yellow：至少一个replica node 不可用，但是数据仍然是完整的。</li><li>red:至少一个 P node 不可用，数据不完整，集群不可用。</li></ol><h3 id="几种查询方式"><a href="#几种查询方式" class="headerlink" title="几种查询方式"></a>几种查询方式</h3><ol><li>query string search： 类似于Url挂参数查询</li><li>query dsl</li><li>query and fliter</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ES-和-Kibana-安装&quot;&gt;&lt;a href=&quot;#ES-和-Kibana-安装&quot; class=&quot;headerlink&quot; title=&quot;ES 和 Kibana 安装&quot;&gt;&lt;/a&gt;ES 和 Kibana 安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;修改了集群默认配置 就会认为是生</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>公考技巧</title>
    <link href="https://wulianling.github.io/2021/10/19/gov-test/"/>
    <id>https://wulianling.github.io/2021/10/19/gov-test/</id>
    <published>2021-10-19T14:53:18.000Z</published>
    <updated>2021-11-02T14:44:24.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="备考指南"><a href="#备考指南" class="headerlink" title="备考指南"></a>备考指南</h3><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><ol><li>人民日报：学习时政</li><li>公考雷达：适合你的岗位，精准匹配</li><li>学习强国＋半月谈：看文章学习申论规范语言，基本上岸的兄弟姊妹都得成本背诵</li><li>粉笔公考：刷题</li><li>百度网盘、喜马拉雅、大黄蜂：保存资料，看课程，听免费的网课</li><li>澎湃新闻：准备面试的时候一定要用，里面的新闻思路都是面试思路</li><li>知乎、小红书、B站：学习上岸前辈的经验</li><li>思维导图：每天把学习的内容做成思维导图，考公是思维清晰胜过做10道题</li><li>每日清单＋大目标：每天的学习内容记录起来，建立计划，每日细分计划</li><li>脑力训练：专注力＋分析能力+查找能力+其他各种能力，脑子越用越活（如果时间特别紧就别下了）</li></ol><h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3><h4 id="一、接语选择题"><a href="#一、接语选择题" class="headerlink" title="一、接语选择题"></a>一、接语选择题</h4><ol><li><p>关注尾句主题，下文对尾句主题的论述或展开</p></li><li><p>干扰项大多是 前文 论述内容</p></li></ol><p>..(未完待续…)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;备考指南&quot;&gt;&lt;a href=&quot;#备考指南&quot; class=&quot;headerlink&quot; title=&quot;备考指南&quot;&gt;&lt;/a&gt;备考指南&lt;/h3&gt;&lt;h3 id=&quot;app&quot;&gt;&lt;a href=&quot;#app&quot; class=&quot;headerlink&quot; title=&quot;app&quot;&gt;&lt;/a&gt;ap</summary>
      
    
    
    
    
    <category term="公考" scheme="https://wulianling.github.io/tags/%E5%85%AC%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>ES核心概念</title>
    <link href="https://wulianling.github.io/2021/10/17/Inverted-Index/"/>
    <id>https://wulianling.github.io/2021/10/17/Inverted-Index/</id>
    <published>2021-10-17T13:56:53.000Z</published>
    <updated>2021-11-03T12:47:04.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="倒排索引：根据关键词，造索引"><a href="#倒排索引：根据关键词，造索引" class="headerlink" title="倒排索引：根据关键词，造索引"></a>倒排索引：根据关键词，造索引</h3><ol><li>分词<ol><li>把字段分词 如：小米手机 分成 小米、手机；</li></ol></li><li>统计<br> 统计分词在在哪里出现，标记出现的位置</li><li>相关度<br> 当查询 如：小米智能手机<ol><li>进行分词，如：小米：智能：手机；分别在倒排索引表中出现的次数  次数越多 表示相关度越高，表示最想要的结果。</li></ol></li></ol><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>单核 CPU 一般大于 100GB  内存 一般大概是20-50GB  磁盘 Raid 一般 SATA3 500MB  SSD 最快 一般 2GB</p><h4 id="倒排索引-查询索引文件不需要模糊查询"><a href="#倒排索引-查询索引文件不需要模糊查询" class="headerlink" title="倒排索引(查询索引文件不需要模糊查询)"></a>倒排索引(查询索引文件不需要模糊查询)</h4><ol><li><p>数据结构</p><ol><li>包含这个关键词的document list </li><li>关键词在每个doc中 出现的次数 TF term frequency 词频</li><li>关键词在索引中出现的次数 IDF inverse doc frequency </li><li>关键词在当前doc中出席那的次数</li><li>每个doc的长度，越长相关度越低</li><li>包含这个关键词的所有doc的平均长度</li></ol></li><li><p>Lucene<br>jar包， 帮我们创建倒排索引，提供了复杂的API<br>如果用Lucene做集群实现搜索，会有哪些问题</p><ol><li>节点一旦宕机，数据丢失，后果不堪设想</li><li>自己维护，麻烦（自己创建管理索引），单台节点的承载请求的能力是有限的，需要人工负载（雨露均沾）。</li></ol></li></ol><h3 id="ES-分布式、高性能、高可用、可伸缩、已维护-ES-不等于-搜索引擎"><a href="#ES-分布式、高性能、高可用、可伸缩、已维护-ES-不等于-搜索引擎" class="headerlink" title="ES: 分布式、高性能、高可用、可伸缩、已维护 ES 不等于 搜索引擎"></a>ES: 分布式、高性能、高可用、可伸缩、已维护 ES 不等于 搜索引擎</h3><ol><li>分布式的搜索，存储和数据分析引擎</li><li>优点<ol><li>面向开发者友好，屏蔽Lucene的复杂特性，集群自动发现</li><li>自动维护数据在过个节点上的建立。</li><li>会帮我做搜索请求的负载均衡</li><li>自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</li><li>ES基于Lucene提供很多高级功能：符合查询，聚合分析，基于地理位置</li><li>对于大公司，可以构建几百台服务器的大型分布式集群，处理PB级别数据，对于小公司，开箱即用，门槛低上手简单。</li><li>相遇传统数据库，提供了全文检索，同义词处理，</li></ol></li><li>应用领域<ol><li>全文检索、高亮、搜索推荐</li><li>各大网站的用户行为日志（点击、浏览、收藏、评论）</li><li>（Business Intelligence 商业智能）,数据分析：数据挖掘统计。</li><li>GitHub:代码托管平台，几千亿代码</li><li>ELK：（Elasticsearch（数据存储）、Logstash(日志采集)、Kibana(可视化) </li></ol></li></ol><h3 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h3><ol><li>Cluster（集群）：每个集群至少包含两个节点。</li><li>Node:集群中的各个节点，一个节点不代表一台服务器。</li><li>Filed：一个数据字段，与index和type一起，可以定位一个doc.</li><li>Document:ES最小的数据单元。</li><li>ype：逻辑上的数据分类。</li><li>Index：一类相同或者类似的doc,比如一个员工索引，商品索引。</li></ol><h3 id="share-分片-（P-Primary-share；R-replica-share）"><a href="#share-分片-（P-Primary-share；R-replica-share）" class="headerlink" title="share 分片  （P:Primary share；R:replica share）"></a>share 分片  （P:Primary share；R:replica share）</h3><ol><li>一个index包含多个share，默认5P，默认每个P分配一个R，P的数量在创建所以韩的时候设置，如果想修改，需要重建索引。</li><li>每个share都是一个Lucene实例，有完整的创建索引的处理请求能力。</li><li>ES会自动在nodes上为我们做shared均衡。</li><li>一个doc是不可能同时存在于多个shared中的，但是可以存在于多个shared中。</li><li>P和对应的R不能同时存在于同一个节点中，所以最低的可用配置是两台节点，互为主备。</li></ol><blockquote><p>不同的数据（类型。结构）不要存放在同一个index中！ 数据被用来做复杂的聚合分析（耗时、耗资源），会导致查询慢。</p></blockquote><blockquote><p>一台机器宕机，保证其他节点数据的完整性<br>横向扩展 share rebalance：数据量的提升，副本(节点)：QPS的提升，高可用</p></blockquote><h3 id="ES容错"><a href="#ES容错" class="headerlink" title="ES容错"></a>ES容错</h3><ol><li>第一步：master选举<ul><li>当master节点宕机的时候，ES会自动的在剩余的机器中选择一个作为master节点</li><li>如果是本节点当选master，票数过半后当选master，然后告诉别的节点没戏了，可以停下来，如果是别的节点当选，那么请求新的master节点加入集群。</li></ul><ol><li>脑裂： 可能会产生多个Master节点,配置：discovery.zen.minimum_master_nodes = N/2+1</li></ol></li><li>Replica容错  <ul><li>R副本提升为 P副本</li></ul></li><li>尝试重启故障机</li><li>数据恢复 ，<ul><li>拷贝增量数据</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;倒排索引：根据关键词，造索引&quot;&gt;&lt;a href=&quot;#倒排索引：根据关键词，造索引&quot; class=&quot;headerlink&quot; title=&quot;倒排索引：根据关键词，造索引&quot;&gt;&lt;/a&gt;倒排索引：根据关键词，造索引&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分词&lt;ol&gt;
&lt;li&gt;把字段分词</summary>
      
    
    
    
    
    <category term="ES" scheme="https://wulianling.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>软考历程</title>
    <link href="https://wulianling.github.io/2021/10/05/compute_soft_test_process/"/>
    <id>https://wulianling.github.io/2021/10/05/compute_soft_test_process/</id>
    <published>2021-10-05T14:36:32.000Z</published>
    <updated>2021-10-05T15:05:35.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的软考之路"><a href="#我的软考之路" class="headerlink" title="我的软考之路"></a>我的软考之路</h3><blockquote><p>路漫漫其修远兮，吾将上下而求索</p></blockquote><h4 id="1-计算机组成与体系结构"><a href="#1-计算机组成与体系结构" class="headerlink" title="1. 计算机组成与体系结构"></a>1. <a href="%22%22">计算机组成与体系结构</a></h4><h4 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. <a href>操作系统</a></h4><h4 id="3-数据库系统"><a href="#3-数据库系统" class="headerlink" title="3. 数据库系统"></a>3. <a href>数据库系统</a></h4><h4 id="4-嵌入式系统"><a href="#4-嵌入式系统" class="headerlink" title="4. 嵌入式系统"></a>4. <a href>嵌入式系统</a></h4><h4 id="5-数据通信与计算机网络"><a href="#5-数据通信与计算机网络" class="headerlink" title="5. 数据通信与计算机网络"></a>5. <a href>数据通信与计算机网络</a></h4><h4 id="6-多媒体基础知识"><a href="#6-多媒体基础知识" class="headerlink" title="6. 多媒体基础知识"></a>6. <a href>多媒体基础知识</a></h4><h4 id="7-系统配置与性能评价"><a href="#7-系统配置与性能评价" class="headerlink" title="7. 系统配置与性能评价"></a>7. <a href>系统配置与性能评价</a></h4><h4 id="8-信息系统基础知识"><a href="#8-信息系统基础知识" class="headerlink" title="8. 信息系统基础知识"></a>8. <a href>信息系统基础知识</a></h4><h4 id="9-软件工程"><a href="#9-软件工程" class="headerlink" title="9. 软件工程"></a>9. <a href>软件工程</a></h4><h4 id="11-新技术应用"><a href="#11-新技术应用" class="headerlink" title="11. 新技术应用"></a>11. <a href>新技术应用</a></h4><h4 id="12-项目管理"><a href="#12-项目管理" class="headerlink" title="12. 项目管理"></a>12. <a href>项目管理</a></h4><h4 id="13-软件体系结构"><a href="#13-软件体系结构" class="headerlink" title="13. 软件体系结构"></a>13. <a href>软件体系结构</a></h4><h4 id="14-安全性知识"><a href="#14-安全性知识" class="headerlink" title="14. 安全性知识"></a>14. <a href>安全性知识</a></h4><h4 id="15-知识产权与法律法规"><a href="#15-知识产权与法律法规" class="headerlink" title="15. 知识产权与法律法规"></a>15. <a href>知识产权与法律法规</a></h4><h4 id="16-标准化知识"><a href="#16-标准化知识" class="headerlink" title="16. 标准化知识"></a>16. <a href>标准化知识</a></h4><h4 id="17-应用数学与经济管理"><a href="#17-应用数学与经济管理" class="headerlink" title="17. 应用数学与经济管理"></a>17. <a href>应用数学与经济管理</a></h4><h4 id="18-专业英语"><a href="#18-专业英语" class="headerlink" title="18. 专业英语"></a>18. <a href>专业英语</a></h4><h4 id="19-未完待续…"><a href="#19-未完待续…" class="headerlink" title="19. (未完待续…)"></a>19. (未完待续…)</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;我的软考之路&quot;&gt;&lt;a href=&quot;#我的软考之路&quot; class=&quot;headerlink&quot; title=&quot;我的软考之路&quot;&gt;&lt;/a&gt;我的软考之路&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;路漫漫其修远兮，吾将上下而求索&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=</summary>
      
    
    
    
    <category term="软考" scheme="https://wulianling.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="学习" scheme="https://wulianling.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>about-time-thinking</title>
    <link href="https://wulianling.github.io/2021/02/15/about-time-thinking/"/>
    <id>https://wulianling.github.io/2021/02/15/about-time-thinking/</id>
    <published>2021-02-15T00:48:49.000Z</published>
    <updated>2021-02-15T01:13:48.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间的样子"><a href="#时间的样子" class="headerlink" title="时间的样子"></a>时间的样子</h3><p style="text-indent:2em">黎明前的黑暗，大年的第四天，我卧靠着床头，多日的假日生活除了吃和睡，没有别的必要的日常，幸福的些许枯燥，而时光飞快，十三天的假期，剩下三天了，今天的此时，已经睡醒了，清醒着，端着手机，也不知道看些什么东西，窗外已经有断断续续的鸡鸣声了，远远近近的，一只鸡认真严肃的在每一户人家窗前经过，给每一个人打鸣，天地间，这么认真对待时光，万年的历史长河中，一个个黑夜到白天，似乎自己没有睡眠，眼前飘着无形的时钟，它优雅的来回踱步，眼里看不见其他，只盯着时间，到了点，清一清喉咙，从肺里掏出恒古不变的卡带，塞进喉咙里，给世界一点声音，告诉天上的月色和星光，到点了，收一收光芒，休息去吧；</p><p style="text-indent:2em">窗外的钠灯下，奇怪的波纹，像风的痕迹，从左边吹过右边，走进窗前，抹去玻璃上的雾气，凑近看个究竟，缺什么也看不到，回来重新藏进被窝里，探出个脑袋，望向窗外，那轻柔有急促、纤细有繁密的时间的风，有吹了起来，却没有风的应有样子，因为他听不到一点点声响，只是不小心被我看见了；</p><p style="text-indent:2em">心里惊喜着，我居然看见了时间，赶紧用文字把它留下来，因为此时我瞥向窗外，它不见了，我想好好的描写它，乘我还记得它的样子， 却一个劲的勾勒其他..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;时间的样子&quot;&gt;&lt;a href=&quot;#时间的样子&quot; class=&quot;headerlink&quot; title=&quot;时间的样子&quot;&gt;&lt;/a&gt;时间的样子&lt;/h3&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;
黎明前的黑暗，大年的第四天，我卧靠着床头，多日的假日生活除了吃和睡</summary>
      
    
    
    
    <category term="我有个一作家梦" scheme="https://wulianling.github.io/categories/%E6%88%91%E6%9C%89%E4%B8%AA%E4%B8%80%E4%BD%9C%E5%AE%B6%E6%A2%A6/"/>
    
    
    <category term="随想" scheme="https://wulianling.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>对比Hashtable、HashMap、TreeMap有什么不同？</title>
    <link href="https://wulianling.github.io/2020/12/03/differ-between-with-Hashtable-HashMap-treeMap/"/>
    <id>https://wulianling.github.io/2020/12/03/differ-between-with-Hashtable-HashMap-treeMap/</id>
    <published>2020-12-03T01:31:35.000Z</published>
    <updated>2021-02-15T01:10:12.652Z</updated>
    
    <content type="html"><![CDATA[<p><strong>对比Hashtable、HashMap、TreeMap有什么不同？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><ul><li>从各种数据结构、典型应用场景，到程序设计实现的技术考量，尤其是在Java8里，HashMap本身发生了非常大的变化，这些都是经常考察的方面。</li><li>理解Map相关类似整体结构，尤其是有序数据结构的一些要点。</li><li>从源码去分析HashMap的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响Map的性能，实践中如何取舍等。</li><li>理解树化改造的相关原理和改进原</li></ul><p><strong>重载equals方法时要遵守的通用约定–自反性,对称性,传递性，一致性，非空性</strong><br><img src="https://www.cnblogs.com/ttylinux/p/6539436.html" alt="重载equals方法时要遵守的通用约定--自反性,对称性,传递性，一致性，非空性"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;对比Hashtable、HashMap、TreeMap有什么不同？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;从各</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="Map" scheme="https://wulianling.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Java反射机制，动态代理是基于什么原理？</title>
    <link href="https://wulianling.github.io/2020/12/02/java-reflection-mechanism-and-dynamic-proxy/"/>
    <id>https://wulianling.github.io/2020/12/02/java-reflection-mechanism-and-dynamic-proxy/</id>
    <published>2020-12-02T02:32:21.000Z</published>
    <updated>2020-12-03T01:25:47.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>谈谈Java反射机制，动态代理是基于什么原理？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><ul><li>考察你对反射机制的了解和掌握程度。</li><li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li><li>JDK动态代理在设计和实现上与cglib等方式有什么不同，进而如何取舍？</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://www.zhihu.com/question/24304289">学习java应该如何理解反射？</a></p><p>静态代理和动态代理：</p><p>静态代理:<br>优点：<br>代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。</p><p>缺点：<br>1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p><p>2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。</p><p>动态代理：</p><p>根据如上的介绍，你会发现每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类<br>所以我们就会想办法可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理</p><p>两种代理简单对比下两种方式各自优势<br>JDK Proxy的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新以保证在新版Java上能够使用。</li><li>代码实现简单。<br>基于类似cglib框架的优势：</li><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似cglib动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;谈谈Java反射机制，动态代理是基于什么原理？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;考察你对反射机制的了解和</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="代理" scheme="https://wulianling.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="反射" scheme="https://wulianling.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>理解Java的字符串，String、StringBufer、StringBuilder有什么区别</title>
    <link href="https://wulianling.github.io/2020/12/02/differ-betwen-String-StringBuffer-and-StringBuilder/"/>
    <id>https://wulianling.github.io/2020/12/02/differ-betwen-String-StringBuffer-and-StringBuilder/</id>
    <published>2020-12-02T02:12:58.000Z</published>
    <updated>2020-12-04T05:53:17.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>理解Java的字符串，String、StringBufer、StringBuilder有什么区别？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。</p><p>如果继续深入，面试官可以从各种不同的角度考察，比如可以：</p><ul><li>通过String和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li><li>考察JVM对象缓存机制的理解以及如何良好地使用。</li><li>考察JVM优化Java代码的一些技巧。</li><li>String相关类的演进，比如Java 9中实现的巨大变化。</li></ul><ul><li>（1） 元素特性<br>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。 </li></ul><p>-（2）顺序特性<br>HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的 值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口 实现排序方式。 </p><p>-（3）初始化与增长方式<br>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。 扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。 </p><p>-（4）线程安全性<br>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低 下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞， 大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。 HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使 用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配 一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。 </p><p>(5)一段话HashMap<br>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时， 通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存 键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 （TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;理解Java的字符串，String、StringBufer、StringBuilder有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="String" scheme="https://wulianling.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>【转载】垃圾回收</title>
    <link href="https://wulianling.github.io/2020/12/01/java-gc/"/>
    <id>https://wulianling.github.io/2020/12/01/java-gc/</id>
    <published>2020-12-01T01:22:41.000Z</published>
    <updated>2020-12-02T02:04:18.750Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要摘自《深入理解Java虚拟机》，内容较多，尽量全面概括了 Java 垃圾回收机制、垃圾回收器以及内存分配策略等内容。了解 Java 垃圾回收之前，需要<a href="https://wulianling.github.io/2020/11/30/JAVA-memory-area-and-memory-model/">先了解 Java内存区域</a></p><h3 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h3><p><strong>垃圾回收主要关注 Java 堆</strong><br><img src="/2020/12/01/java-gc/jdk8-java-memory.png"><br>Java 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而 Java 堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p><h4 id="判断哪些对象需要被回收"><a href="#判断哪些对象需要被回收" class="headerlink" title="判断哪些对象需要被回收"></a>判断哪些对象需要被回收</h4><p>有以下两种方法：</p><ol><li>引用计数法<br>给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。</li><li>可达性分析算法<br>通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。<br><img src="/2020/12/01/java-gc/gc1.png"><br>在Java语言中，可作为 GC Roots 的对象包括下面几种：</li></ol><ul><li>a.虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>b.方法区中类静态属性引用的对象。</li><li>c. 方法区中常量引用的对象。</li><li>d. 本地方法栈中 JNI（Native方法）引用的对象</li></ul><p>作为 GC Roots 的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为 Roots，因此必须选取确定存活的引用类型对象。</p><p>GC 管理的区域是 Java 堆，虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。</p><p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。</p><h4 id="强、软、弱、虚引用"><a href="#强、软、弱、虚引用" class="headerlink" title="强、软、弱、虚引用"></a>强、软、弱、虚引用</h4><p>JDK1.2 以前，一个对象只有被引用和没有被引用两种状态。</p><p>后来，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><ol><li>强引用就是指在程序代码之中普遍存在的，类似”Object obj=new Object()”这类的引用，垃圾收集器永远不会回收存活的强引用对象。</li><li>软引用：还有用但并非必需的对象。在系统<strong>将要发生内存溢出异常之前</strong> ，将会把这些对象列进回收范围之中进行第二次回收。</li><li>弱引用也是用来描述非必需对象的，被弱引用关联的对象 <strong>只能生存到下一次垃圾收集发生之前</strong> 。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用是最弱的一种引用关系。 <strong>无法通过虚引用来取得一个对象实例</strong>。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><p><img src="/2020/12/01/java-gc/gc2.png"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li>如果对象在进行可达性分析后发现没有与<strong>GCRoots相连接的引用链</strong>，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。</li><li>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。</li><li>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去<strong>执行</strong>它。</li></ol><p>这里所谓的“<strong>执行</strong>”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 finalize() 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。</p><p>测试程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizerTest &#123;</span><br><span class="line">    public static FinalizerTest object;</span><br><span class="line">    public void isAlive() &#123;</span><br><span class="line">        System.out.println(&quot;I&#39;m alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;method finalize is running&quot;);</span><br><span class="line">        object &#x3D; this;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        object &#x3D; new FinalizerTest();</span><br><span class="line">        &#x2F;&#x2F; 第一次执行，finalize方法会自救</span><br><span class="line">        object &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (object !&#x3D; null) &#123;</span><br><span class="line">            object.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;I&#39;m dead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 第二次执行，finalize方法已经执行过</span><br><span class="line">        object &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (object !&#x3D; null) &#123;</span><br><span class="line">            object.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;I&#39;m dead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method finalize is running</span><br><span class="line">I&#39;m alive</span><br><span class="line">I&#39;m dead</span><br></pre></td></tr></table></figure><p>如果不重写 finalize()，输出将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m dead</span><br><span class="line">I&#39;m dead</span><br></pre></td></tr></table></figure><p>从执行结果可以看出：<br>第一次发生 GC 时，finalize() 方法的确执行了，并且在被回收之前成功逃脱；<br>第二次发生 GC 时，由于 finalize() 方法只会被 JVM 调用一次，object 被回收</p><p>值得注意的是，使用 finalize() 方法来“拯救”对象是不值得提倡的，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize() 能做的工作，使用 try-finally 或者其它方法都更适合、及时。</p><h4 id="Java-堆永久代的回收"><a href="#Java-堆永久代的回收" class="headerlink" title="Java 堆永久代的回收"></a>Java 堆永久代的回收</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><ol><li>回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做”abc”的，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li><strong>类需要同时满足下面 3 个条件才能算是“无用的类”：</strong></li></ol><ul><li>a. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>b. 加载该类的 ClassLoader 已经被回收。</li><li>c. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p>一共有 4 种：</p><ol><li>标记-清除算法</li><li>复制算法</li><li>标记整理算法</li><li>分代收集算法</li></ol><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它的主要不足有两个：</p><ol><li>效率问题，标记和清除两个过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p>标记—清除算法的执行过程如下图。<br><img src="/2020/12/01/java-gc/gc3.png"></p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><img src="/2020/12/01/java-gc/gc4.png"></p><p>现在的商业虚拟机都采用这种算法来回收新生代，IBM 研究指出新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。</p><p>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden:Survivor = 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（其中一块Survivor不可用），只有 10% 的内存会被“浪费”。</p><p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在 98% 的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。</p><p>内存的分配担保也一样，如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分配担保的内容，在本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下：<br><img src="/2020/12/01/java-gc/gc5.png"></p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。</p><p>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h4 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h4><p><strong>枚举根节点</strong></p><p>以可达性分析中从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><p>另外，可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须不可以出现分析过程中对象引用关系还在不断变化的情况，否则分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun将这件事情称为”Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</p><p>因此，目前的主流 Java 虚拟机使用的都是准确式 GC（即虚拟机可以知道内存中某个位置的数据具体是什么类型。），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。</p><p>在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录栈和寄存器中哪些位置是引用。这样， GC 在扫描时就可以直接得知这些信息了。</p><p><strong>安全点（Safepoint）</strong></p><p>在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。</p><p>实际上，HotSpot 也的确没有为每条指令都生成 OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC ，只有在到达安全点时才能暂停。</p><p>Safepoint 的选定既不能太少以致于 GC 过少，也不能过于频繁以致于过分增大运行时的负荷。</p><p>对于 Safepoint，另一个需要考虑的问题是如何在 GC 发生时让所有线程都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p><p>其中抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。</p><p>而主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><p><strong>安全区域（Safe Region）</strong></p><p>使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的Safepoint。但是，程序“不执行”的时候呢？</p><p>所谓的程序不执行就是没有分配 CPU 时间，典型的例子就是线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配 CPU 时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化。</strong></p><p>在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。这里讨论的收集器基于JDK 1.7 Update 14之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图所示<br><img src="/2020/12/01/java-gc/gc6.png"><br>上图展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析 CMS 和 G1 这两款相对复杂的收集器，了解它们的部分运作细节。</p><h5 id="Serial收集器（串行收集器）"><a href="#Serial收集器（串行收集器）" class="headerlink" title="Serial收集器（串行收集器）"></a>Serial收集器（串行收集器）</h5><p>Serial 收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机新生代收集的唯一选择。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p>“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了 Serial/Serial Old 收集器的运行过程。<br><img src="/2020/12/01/java-gc/gc7.png"><br>实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc8.png"><br>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器（并发收集器，后面有介绍）配合工作。</p><p>ParNew 收集器在单 CPU 的环境中不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。</p><p>当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（如 32 个)的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>注意，从 ParNew 收集器开始，后面还会接触到几款并发和并行的收集器。这里有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和 ParNew 都一样，那它有什么特别之处呢？<br>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。</p><p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是99% 。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p><p>MaxGCPauseMillis参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。</p><p>不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>GCTimeRatio 参数的值应当是一个 0 到 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99 ，就是允许最大 1%（即 1/（1+99））的垃圾收集时间。</p><p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。这两点都将在后面的内容中详细讲解。Serial Old 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc9.png"></p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。</p><p>原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（PS MarkSweep）收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。</p><p>由于老年代 Serial Old 收集器在服务端应用性能上的“拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。</p><p>直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。Parallel Old 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc10.png"></p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含”Mark Sweep”）上就可以看出，CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。<br><img src="/2020/12/01/java-gc/gc11.png"></p><p>CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是 CMS 还远达不到完美的程度，它有以下 3 个明显的缺点：<br><strong>第一、导致吞吐量降低</strong>。CMS 收集器对 CPU 资源非常敏感。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p><p>CMS 默认启动的回收线程数是（CPU数量+3）/4，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如2个）时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。</p><p><strong>第二、CMS 收集器无法处理浮动垃圾（Floating Garbage）</strong>，可能出现”Concurrent Mode Failure”失败而导致另一次 Full GC（新生代和老年代同时回收） 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p><p>在 JDK 1.5 的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中，CMS 收集器的启动阈值已经提升至 92% 。</p><p>要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent ModeFailure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</p><p><strong>第三、产生空间碎片</strong>。 CMS 是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。</p><p>为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。</p><p><strong>并行与并发</strong>： G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p><p><strong>分代收集</strong>： 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</p><p><strong>空间整合</strong>： 与 CMS 的“标记—清理”算法不同，G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC 。</p><p><strong>可预测的停顿</strong>： 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</p><p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是Garbage-First名称的来由），保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 <strong>Remembered Set</strong> 来避免全堆扫描的。</p><p>G1 中每个Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol><p>G1 的前几个步骤的运作过程和 CMS 有很多相似之处。</p><p>初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p>并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p><p>而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。</p><p>最后在筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。</p><p><img src="/2020/12/01/java-gc/gc12.png"></p><h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>阅读 GC 日志是处理 Java 虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。</p><p>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的 GC 日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125:[GC[DefNew:3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]</span><br><span class="line">100.667:[Full GC[Tenured:0 K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm:2999K-＞2999K（21248K）]，0.0150007 secs][Times:user&#x3D;0.01 sys&#x3D;0.00，real&#x3D;0.02 secs]</span><br></pre></td></tr></table></figure><p>最前面的数字33.125： 和 100.667： 代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p><p>GC 日志开头的 [GC 和 [Full GC 说明了这次垃圾收集的停顿类型，而不是用来区分新生代 GC 还是老年代 GC 的。</p><p>如果有 Full ，说明这次 GC 是发生了 Stop-The-World 的，例如下面这段新生代收集器 ParNew 的日志也会出现 [Full GC（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。如果是调用 System.gc() 方法所触发的收集，那么在这里将显示 [Full GC（System）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736:[ParNew:261599K-＞261599K（261952K），0.0000288 secs]</span><br></pre></td></tr></table></figure><p>接下来的 [DefNew、[Tenured、[Perm 表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的，例如上面样例所使用的 Serial 收集器中的新生代名为 “Default New Generation”，所以显示的是 [DefNew。如果是 ParNew 收集器，新生代名称就会变为 [ParNew，意为 “Parallel New Generation”。如果采用 Parallel Scavenge 收集器，那它配套的新生代称为 PSYoungGen，老年代和永久代同理，名称也是由收集器决定的。</p><p>后面方括号内部的 <strong bgcolor="grey">3324K-＞152K（3712K）</strong>&gt;含义是<strong bgcolor="grey">GC 前该内存区域已使用容量 -＞ GC 后该内存区域已使用容量 （该内存区域总容量）</strong>。而在<strong bgcolor="grey">方括号之外的 3324K-＞152K（11904K）</strong> 表示 <strong bgcolor="grey">GC 前 Java 堆已使用容量 -＞ GC 后 Java 堆已使用容量 （Java 堆总容量）</strong>。</p><p>再往后，<strong bgcolor="grey">.0025925 secs </strong>表示该内存区域 GC 所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如<strong bgcolor="grey"> [Times:user=0.01 sys=0.00，real=0.02 secs] </strong>，这里面的 user、sys 和 real 与 Linux 的 time 命令所输出的时间含义一致，分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。</p><p>CPU 时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O、等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以读者看到 user 或 sys 时间超过 real 时间是完全正常的。</p><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p>JDK 1.7 中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，在表3-2中整理了这些参数供读者实践时参考。<br><img src="/2020/12/01/java-gc/gc13.png"><br><img src="/2020/12/01/java-gc/gc14.png"></p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p><img src="/2020/12/01/java-gc/gc15.png"></p><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。<br>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final int_1MB&#x3D;1024 * 1024；</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails</span><br><span class="line">         -XX:SurvivorRatio&#x3D;8</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static void testAllocation () &#123;</span><br><span class="line">            byte[] allocation1，allocation2，allocation3，allocation4；</span><br><span class="line">            allocation1 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation2 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation3 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation4 &#x3D; new byte[4 * _1MB]；&#x2F;&#x2F;出现一次Minor GC</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC[DefNew:6651K-＞148K（9216K），0.0070106 secs]6651K-＞6292K（19456K），</span><br><span class="line">0.0070426 secs][Times:user&#x3D;0.00 sys&#x3D;0.00，real&#x3D;0.00 secs]</span><br><span class="line">Heap</span><br><span class="line">def new generation total 9216K,used 4326K[0x029d0000，0x033d0000，0x033d0000）</span><br><span class="line">eden space 8192K，51%used[0x029d0000，0x02de4828，0x031d0000）</span><br><span class="line">from space 1024K，14%used[0x032d0000，0x032f5370，0x033d0000）</span><br><span class="line">to space 1024K，0%used[0x031d0000，0x031d0000，0x032d0000）</span><br><span class="line">tenured generation total 10240K,used 6144K[0x033d0000，0x03dd0000，0x03dd0000）</span><br><span class="line">the space 10240K，60%used[0x033d0000，0x039d0030，0x039d0200，0x03dd0000）</span><br><span class="line">compacting perm gen total 12288K,used 2114K[0x03dd0000，0x049d0000，0x07dd0000）</span><br><span class="line">the space 12288K，17%used[0x03dd0000，0x03fe0998，0x03fe0a00，0x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure><p>上方代码的 <strong>testAllocation()</strong> 方法中，尝试分配 3 个 2MB 大小和 1 个 4MB 大小的对象，在运行时通过**-Xms20M、-Xmx20M、-Xmn10M<strong>这 3 个参数限制了 Java 堆大小为 20MB ，不可扩展，其中 10MB 分配给新生代，剩下的 10MB 分配给老年代。</strong>-XX:SurvivorRatio=8<strong>决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8:1，从输出的结果也可以清晰地看到 **eden space 8192K、from space 1024K、to space 1024K</strong> 的信息，新生代总可用空间为 9216KB（Eden区+1个Survivor区的总容量）。</p><p>执行 <strong>testAllocation()</strong> 中分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB ，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p><p>这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（Survivor 空间只有 1MB 大小），所以只好通过分配担保机制提前转移到老年代去。</p><p>这次 GC 结束后，4MB 的 allocation4 对象顺利分配在 Eden 中，因此程序执行完的结果是 Eden 占用 4MB（被allocation4占用），Survivor 空闲，老年代被占用 6MB（被allocation1、allocation2、allocation3占用）。通过 GC 日志可以证实这一点。</p><p><strong>Minor GC 和 Full GC 有什么不一样吗？</strong></p><ul><li>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代</strong></p><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（ byte[] 数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（特别是短命大对象，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int_1MB&#x3D;1024 * 1024；</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio&#x3D;8</span><br><span class="line">         *-XX:PretenureSizeThreshold&#x3D;3145728</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static void testPretenureSizeThreshold () &#123;</span><br><span class="line">            byte[] allocation；</span><br><span class="line">            allocation &#x3D; new byte[4 * _1MB]；&#x2F;&#x2F;直接分配在老年代中</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def new generation total 9216K,used 671K[0x029d0000，0x033d0000，0x033d0000）</span><br><span class="line">eden space 8192K，8%used[0x029d0000，0x02a77e98，0x031d0000）</span><br><span class="line">from space 1024K，0%used[0x031d0000，0x031d0000，0x032d0000）</span><br><span class="line">to space 1024K，0%used[0x032d0000，0x032d0000，0x033d0000）</span><br><span class="line">tenured generation total 10240K,used 4096K[0x033d0000，0x03dd0000，0x03dd0000）</span><br><span class="line">the space 10240K，40%used[0x033d0000，0x037d0010，0x037d0200，0x03dd0000）</span><br><span class="line">compacting perm gen total 12288K,used 2107K[0x03dd0000，0x049d0000，0x07dd0000）</span><br><span class="line">the space 12288K，17%used[0x03dd0000，0x03fdefd0，0x03fdf000，0x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure><p>执行以上代码中的 <strong>testPretenureSizeThreshold()</strong> 方法后，我们看到 Eden 空间几乎没有被使用，而老年代的 10MB 空间被使用了 40%，也就是 4MB 的 allocation 对象直接就分配在老年代中，这是因为 PretenureSizeThreshold 参数被设置为 3MB（就是 3145728，这个参数不能像 -Xmx 之类的参数一样直接写 3MB），因此超过 3MB 的对象都会直接在老年代进行分配。</p><p>注意 PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge 收集器不认识这个参数，Parallel Scavenge 收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p><p><strong>长期存活的对象将进入老年代</strong><br>虚拟机给每个对象定义了一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1 。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。</p><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，无须等到 MaxTenuringThreshold 中要求的年龄，同年对象达到 Survivor 空间的一半后，他们以及年龄大于他们的对象都将直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代<br>所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC ，否则将进行 Full GC 。</p><p>转载来源：<a href="https://www.cnblogs.com/czwbig/p/11127159.html">https://www.cnblogs.com/czwbig/p/11127159.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要摘自《深入理解Java虚拟机》，内容较多，尽量全面概括了 Java 垃圾回收机制、垃圾回收器以及内存分配策略等内容。了解 Java 垃圾回收之前，需要&lt;a href=&quot;https://wulianling.github.io/2020/11/30/JAVA-memo</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="gc" scheme="https://wulianling.github.io/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Java内存区域（运行时数据区域）和内存模型（JMM）</title>
    <link href="https://wulianling.github.io/2020/11/30/JAVA-memory-area-and-memory-model/"/>
    <id>https://wulianling.github.io/2020/11/30/JAVA-memory-area-and-memory-model/</id>
    <published>2020-11-30T08:01:07.000Z</published>
    <updated>2020-11-30T09:24:41.950Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存区域和内存模型是不一样的东西，内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。</p><p>而内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式，如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。</p><h3 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h3><p>众所周知，Java 虚拟机有自动内存管理机制，如果出现内存泄漏和溢出方面的问题，排查错误就必须要了解虚拟机是怎样使用内存的。<br>下图是 JDK8 之后的 JVM 内存布局。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/jdk8-java-memory.png"></p><p>JDK8 之前的内存区域图如下:<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/before-jkk8-java-memory.png"></p><p>在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 java.lang.OutOfMemoryError: PermGen ，为此我们不得不对虚拟机做调优。<br>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因:</p><ul><li><ol><li>由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li></ol></li><li><ol start="2"><li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。<br>根据上面的各种原因，PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。</li></ol></li></ul><blockquote><p>引用自<a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/">https://www.sczyh30.com/posts/Java/jvm-metaspace/</a></p></blockquote><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。</p><p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是<strong>线程私有</strong>的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>在活动线程中，只有位栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/stacks.png"></p><h5 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表"></a>1.局部变量表</h5><p>局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法<strong>，则在 index[0] 位置上存储的是方法所属对象的实例引用</strong>，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。</p><p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p><h5 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2.操作栈"></a>2.操作栈</h5><p>操作栈是个初始状态为空的<strong>桶式结构栈</strong>。在方法执行过程中， 会有各种指令往<br>栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎， 其中的栈指的就是操<br>作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。</p><p><strong>i++ 和 ++i 的区别：</strong></p><ol><li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li><li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li></ol><p>之前之所以说 i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。</p><h5 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h5><p>每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接</p><h5 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h5><p>方法执行时有两种退出情况：</p><ol><li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；</li><li>异常退出。</li></ol><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ol><li>返回值压入上层调用栈帧。</li><li>异常信息抛给能够处理的栈帧。</li><li>PC计数器指向方法调用后的下一条指令。</li></ol><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><p>线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。本地方法可以通过<br><strong>JNI(Java Native Interface)</strong> 来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。 当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对内存不足的情况，本地方法栈还是会抛出 nativeheapOutOfMemory。</p><p><strong>JNI</strong> 类本地方法最著名的应该是 System.currentTimeMillis() ，JNI使 Java 深度使用操作系统的特性功能，复用非 Java 代码。 但是在项目过程中， 如果大量使用其他语言来实现 JNI , 就会丧失跨平台特性。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有<strong>线程共享的一块内存区域</strong>，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p><p>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个<strong>线程共享的内存区域</strong>，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然<br>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><p><strong>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</strong></p><p>为什么要使用元空间取代永久代的实现？</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，<br>太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>将 HotSpot 与 JRockit 合二为一。</li></ol><p><strong>运行时常量池</strong></p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>直接内存</strong></p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。</p><p>在 JDK 1.4 中新加入了 NIO，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/java-memory-area.png"></p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量（堆内存中的实例域，静态域和数组元素）来完成隐式通信。<br>Java 内存模型（JMM）控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。</p><h4 id="计算机高速缓存和缓存一致性"><a href="#计算机高速缓存和缓存一致性" class="headerlink" title="计算机高速缓存和缓存一致性"></a>计算机高速缓存和缓存一致性</h4><p>计算机在高速的 CPU 和相对低速的存储设备之间使用高速缓存，作为内存和处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。</p><p>在多处理器的系统中(或者单处理器多核的系统)，每个处理器内核都有自己的高速缓存，它们有共享同一主内存(Main Memory)。</p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><p>为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。</p><p><a href="cache1.pag"></a></p><h4 id="JVM主内存与工作内存"><a href="#JVM主内存与工作内存" class="headerlink" title="JVM主内存与工作内存"></a>JVM主内存与工作内存</h4><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（线程共享的变量）存储到内存和从内存中取出变量这样底层细节。</p><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p>这里的工作内存是 JMM 的一个抽象概念，也叫本地内存，其存储了该线程以读 / 写共享变量的副本。</p><p><strong>就像每个处理器内核拥有私有的高速缓存，JMM 中每个线程拥有私有的本地内存。</strong></p><p>不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行，一是通过消息传递，二是共享内存。Java 线程间的通信采用的是共享内存方式，线程、主内存和工作内存的交互关系如下图所示：<br><a href="cache2.pag"></a></p><p>这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</p><h4 id="重排序和happens-before规则"><a href="#重排序和happens-before规则" class="headerlink" title="重排序和happens-before规则"></a>重排序和happens-before规则</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><a href="cache3.pag"></a></p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入<strong>内存屏障</strong>（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。</p><p><strong>happens-before</strong></p><p>从 JDK5 开始，java 内存模型提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。</p><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p><strong>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong></p><p>如果 A happens-before B，那么 Java 内存模型将向程序员保证—— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。<br>重要的 happens-before 规则如下：</p><ol><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ol><p>下图是 happens-before 与 JMM 的关系<br><a href="happens-before.png"></a></p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile 可以说是 JVM 提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：</p><ol><li><p><strong>保证此变量对所有线程的可见性</strong>。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。<br>注意，volatile 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。而 synchronized 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得线程安全的。</p></li><li><p><strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p></li></ol><p>转载来源：<a href="https://www.cnblogs.com/czwbig/p/11127124.html">https://www.cnblogs.com/czwbig/p/11127124.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 内存区域和内存模型是不一样的东西，内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。&lt;/p&gt;
&lt;p&gt;而内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RA</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="JVM" scheme="https://wulianling.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>谈谈fnal、fnally、 fnalize有什么不同？</title>
    <link href="https://wulianling.github.io/2020/11/30/what-differ-about-final-finally-finalize/"/>
    <id>https://wulianling.github.io/2020/11/30/what-differ-about-final-finally-finalize/</id>
    <published>2020-11-30T06:51:35.000Z</published>
    <updated>2020-11-30T07:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong>谈谈fnal、fnally、 fnalize有什么不同？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察你对性能、并发、对象生命周期或垃圾 收集基本过程等方面的理解。</p><p><strong>final</strong></p><ul><li>我们可以将方法或者类声明为fnal，这样就可以明确告知别人，这些行为是不许修改的。</li><li>使用fnal修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成fnal</li><li>fnal变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值fnal变量，有利于减少额外的同步开 销，也可以省去一些防御性拷贝的必要。</li></ul><p><strong>finally</strong><br>对于fnally，明确知道怎么使用就足够了</p><p>特例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; do something  Sysem.exit(1); </span><br><span class="line">&#125; fnally&#123;  </span><br><span class="line">Sysem.out.println(“Print from fnally”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面fnally里面的代码可不会被执行的哦</p><p><strong>finalize</strong><br>finalize()是Object中的方法，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，，在Java 9中，甚至明确将Object.fnalize()标记为deprecated！如果没有特别的原因，不要实 现fnalize方法，也不要指望利用它来进行资源回收</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><ol><li><strong>注意，final 不是immutable！</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fnal Lis&lt;String&gt; srLis &#x3D; new ArrayLis&lt;&gt;(); </span><br><span class="line">srLis.add(&quot;Hello&quot;); srLis.add(&quot;world&quot;);  </span><br><span class="line"> Lis&lt;String&gt; unmodifableStrLis &#x3D; Lis.of(&quot;hello&quot;, &quot;world&quot;); </span><br><span class="line"> unmodifableStrLis.add(&quot;again&quot;);</span><br></pre></td></tr></table></figure>在上面这个例子中，List.of方法创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。在上面这个例子中，List.of方法创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。</li></ol><p>Immutable在很多场景是非常棒的选择，某种意义上说，Java语言目前并没有原生的不可变支持，如果要实现immutable的类，我们需要做到：</p><ul><li>将class自身声明为fnal，这样别人就不能扩展来绕过限制了。</li><li>将所有成员变量定义为private和fnal，并且不要实现setter方法。</li><li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li><li>如果确实需要实现getter方法，或者其他可能会返回内部状态的方法，使用copy-on-write原则，创建私有的copy。</li></ul><p><strong>copy-on-write原则</strong>，即写时复制。其核心思想是，有线程使用容器中的数据时，<strong>如果是写入</strong>，则复制出一个新容器，修改新容器中的数据后，再将引用指向新容器。<strong>如果是读操作</strong>则正常读引用地址中的容器数据。这里需要注意的是，复制新容器时底层通过copyof()方法来实现的，这是一个深层复制方法，即新容器是一个新的对象，在堆中有自己的内存区域，操作新容器不会影响旧容器，当然这也会增加内存开销。所以在复制的时候也加了锁，否则多线程会复制出多个对象占用内存，很容易导致OOM。</p><ol start="2"><li><strong>fnalize真的那么不堪？</strong><br>fnalize是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？<br>fnalize被设计成在对象被垃圾收集前调用，这就意味着实现了fnalize方法的对象是个“特殊公民”，JVM要对它进行额外处理。fnalize本质上成为了快速回收的阻碍者，可能 导致你的对象经过多个垃圾收集周期才能被回收。</li><li><strong>有什么机制可以替换fnalize吗？</strong><br>Java平台目前在逐步使用java.lang.ref.Cleaner来替换掉原有的fnalize实现。Cleaner的实现利用了幻象引用（PhantomReference），这是一种常见的所谓post-mortem清理 机制。我会在后面的专栏系统介绍Java的各种引用，利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的 资源），它比fnalize更加轻量、更加可靠。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CleaningExample implements AutoCloseable &#123;</span><br><span class="line">&#x2F;&#x2F; A cleaner, preferably one shared within a library</span><br><span class="line">    private satic fnal Cleaner cleaner &#x3D; &lt;cleaner&gt;;</span><br><span class="line">    satic class State implements Runnable &#123;</span><br><span class="line">        State(...) &#123;</span><br><span class="line">        &#x2F;&#x2F; initialize State needed for cleaning action</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; cleanup action accessing State, executed at mos once</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private fnal State;</span><br><span class="line">    private fnal Cleaner.Cleanable cleanable</span><br><span class="line">    public CleaningExample() &#123;</span><br><span class="line">        this.sate &#x3D; new State(...);</span><br><span class="line">        this.cleanable &#x3D; cleaner.regiser(this, sate);</span><br><span class="line">    &#125;</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>实现AutoCloseable 重写close方法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;谈谈fnal、fnally、 fnalize有什么不同？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点&lt;/h3&gt;&lt;p&gt;主要是从语法和使用实践角度</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Exception和Error有什么区别？</title>
    <link href="https://wulianling.github.io/2020/11/30/what-differ-about-Exception-and-error/"/>
    <id>https://wulianling.github.io/2020/11/30/what-differ-about-Exception-and-error/</id>
    <published>2020-11-30T05:26:14.000Z</published>
    <updated>2020-11-30T06:28:43.753Z</updated>
    
    <content type="html"><![CDATA[<p><strong>请对比Exception和Error，另外，运行时异常与一般异常有什么区别？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>分析Exception和Error的区别，是从概念角度考察了java处理机制。总得来说，还处于理解的层面</p><h3 id="一、异常机制的概述"><a href="#一、异常机制的概述" class="headerlink" title="一、异常机制的概述"></a>一、异常机制的概述</h3><p>异常机制是指当<strong>程序出现错误</strong>后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。</p><p> 程序错误分为三种：1.编译错误；2.运行时错误；3.逻辑错误。<br>1）<strong>编译错误</strong>是因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置，这个也是大家在刚接触编程语言最常遇到的问题。<br>2）<strong>运行时错误</strong>是因为程序在执行时，运行环境发现了不能执行的操作。<br>3）<strong>逻辑错误</strong>是因为程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制。</p><h3 id="二、异常的结构"><a href="#二、异常的结构" class="headerlink" title="二、异常的结构"></a>二、异常的结构</h3><p> 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p><p> <img src="/2020/11/30/what-differ-about-Exception-and-error/throwable.png"></p><p> <strong>Throwable：</strong><br>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理。</p><p>**Error（错误）:**是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 </p><p><strong>Exception（异常）</strong>分两大类：运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。<br>  1.<strong>运行时异常</strong>：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br>  2.<strong>非运行时异常 （编译异常）</strong>：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><ol><li><p><strong>可查异常（编译器要求必须处置的异常）：</strong><br>正确的程序在运行中，很容易出现的、情理可容的异常状况。除了Exception中的RuntimeException及RuntimeException的子类以外，其他的Exception类及其子类(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p></li><li><p><strong>不可查异常(编译器不要求强制处置的异常):</strong><br>包括运行时异常（RuntimeException与其子类）和错误（Error）。RuntimeException表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</p></li></ol><h3 id="三、异常处理的机制"><a href="#三、异常处理的机制" class="headerlink" title="三、异常处理的机制"></a>三、异常处理的机制</h3><p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><ol><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。详细信息请查看《<a href="https://blog.csdn.net/qq_29229567/article/details/89397648">简述throw-throws异常抛出</a>》。</li><li>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。详细信息请查看《<a href="https://blog.csdn.net/qq_29229567/article/details/87277744">Java：简述try-catch-finally异常捕获</a>》。</li></ol><h3 id="四、异常处理原则"><a href="#四、异常处理原则" class="headerlink" title="四、异常处理原则"></a>四、异常处理原则</h3><ol><li><strong>尽量不要粗活蕾西Ex学测评题欧尼这样的通用异常</strong></li><li><strong>不要生吞异常</strong></li><li><strong>throw early，catch late</strong><br>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处 理，可以选择保留原有异常的cause信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</li></ol><h3 id="五、性能角度下的异常处理机制"><a href="#五、性能角度下的异常处理机制" class="headerlink" title="五、性能角度下的异常处理机制"></a>五、性能角度下的异常处理机制</h3><ul><li>try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同 时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li>Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><h3 id="六、相关的问题"><a href="#六、相关的问题" class="headerlink" title="六、相关的问题"></a>六、相关的问题</h3><ol><li><p><strong>为什么要创建自己的异常？</strong><br>答：当Java内置的异常都不能明确的说明异常情况的时候，需要创建自己的异常。</p></li><li><p><strong>应该在声明方法抛出异常还是在方法中捕获异常？</strong><br>答：捕捉并处理知道如何处理的异常，而抛出不知道如何处理的异常。</p></li><li><p><strong>ClassNotFoundException和NoClassDefFoundError的区别?</strong><br>答：　ClassNotFoundException是一个检查异常。从类继承层次上来看，ClassNotFoundException是从Exception继承的，所以ClassNotFoundException是一个检查异常。<br><img src="/2020/11/30/what-differ-about-Exception-and-error/ClassNotFoundException.png"><br>NoClassDefFoundError异常，看命名后缀是一个Error。从类继承层次上看，NoClassDefFoundError是从Error继承的。和ClassNotFoundException相比，明显的一个区别是，NoClassDefFoundError并不需要应用程序去关心catch的问题。<br><img src="/2020/11/30/what-differ-about-Exception-and-error/NoClassDefFoundError.png"></p></li></ol><p><strong>总结</strong></p><table style>    <tr>        <td style="text-align:center">ClassNotFoundException</td>        <td style="text-align:center">NoClassDefFoundError</td>    </tr>    <tr>        <td>从java.lang.Exception继承，是一个Exception类型</td>        <td>从java.lang.Error继承，是一个Error类型</td>    </tr>    <tr>        <td>当动态加载Class的时候找不到类会抛出该异常</td>        <td>当编译成功以后执行过程中Class找不到导致抛出该错误</td>    </tr>     <tr>        <td>一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出</td>        <td>由JVM的运行时系统抛出</td>    </tr></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;请对比Exception和Error，另外，运行时异常与一般异常有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点&lt;/h3&gt;&lt;p&gt;分析E</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="异常" scheme="https://wulianling.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>java平台的理解</title>
    <link href="https://wulianling.github.io/2020/11/30/Understanding-of-Java-platform/"/>
    <id>https://wulianling.github.io/2020/11/30/Understanding-of-Java-platform/</id>
    <published>2020-11-30T03:20:19.000Z</published>
    <updated>2021-10-19T12:35:00.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>谈谈你对Java平台的理解？“Java是解释执行”，这句话正确吗？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>题目是开放性的，往往考察的是多个方面，比如：</p><ol><li>基础知识理解是否很清晰</li><li>是否掌握Java平台的主要模块和运行原理等</li></ol><p>你需要尽量表现出自己的思维升入并系统化，java知识理解的也比较拳迷看，一定要避免让面试官觉得你是一个“知其然不知其所以然”的人.</p><p style="text-indent:2em">    对于java平台的理解，可以从很多方面简明扼要的谈一下，例如：<ol><li>java的特性，包括泛型 、Lambda等语言特性</li><li>基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。</li><li>或者谈谈JVM的一些基础概念和机制，比如JAVA的类加载机制，常用版本内嵌的Class-Loader，例如Bootstrap、Application和Exception Class-loader；类加载的大只过程：加载、验证、连接、初始化；自定义Class-Loader等。还有垃圾收集的基本原理，最常见的垃圾收集机制，如SerialGC、ParallelGC，CMS、G1等</li></ol></p><h3 id="★学习足迹"><a href="#★学习足迹" class="headerlink" title="★学习足迹"></a>★学习足迹</h3><h2 id="JAVA代码的运行流程"><a href="#JAVA代码的运行流程" class="headerlink" title="JAVA代码的运行流程"></a>JAVA代码的运行流程</h2><p style="text-indent:2em">我们编写的代码都是在java文件中编写的，然后会编译成class字节码文件。当我们使用到哪个类的时候就会通过类加载器把class字节码文件中的类加载到jvm内存中，然后就是在jvm内存中运行我们的代码了。类加载器是如何把类加载到jvm内存中的，小伙伴们有考虑过吗？</p><h2 id="JVM什么时候加载类"><a href="#JVM什么时候加载类" class="headerlink" title="JVM什么时候加载类"></a>JVM什么时候加载类</h2><p style="text-indent:2em">一个类的加载过程会经历如下的几个过程：</p><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong></p><p><strong>加载</strong></p><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p><p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p><p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p><p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p><p>jvm是什么时候去加载类的呢？<br>程序的入口，具有main方法的类，肯定是最开始的时候就加载到jvm中了。<br>jvm是通过什么方式对类进行加载的呢？<br>就是类加载器。</p><p><strong>jvm的类加载器总体上可以分成4层:</strong></p><ol><li>动类加载器<br> 首先就是jvm启动的第一道关口，启动类加载器Bootstrap ClassLoader，它主要是加载java的核心类。<br>相信大家都知道，无论是什么环节下运行java程序，都是要安装jvm虚拟机环境的，而在这个环境的目录中是有一个lib文件夹的，这个文件下就是java最核心的类库，支撑着java系统的运行.<br> 所以一旦jvm启动，那么首先就会通过启动类加载器去加载lib文件夹下的核心类库。</li><li>扩展类加载器<br> 然后我们就到了第二层，扩展类加载器Extension ClassLoader，这个类加载器其实与启动类加载器是类似的。<br>在我们的jvm虚拟机环境目录下，是有一个lib/ext的文件夹的，这里面的类就是java运行环境的一些扩展类，这些扩展类就是在jvm启动后，通过扩展类加载器进行加载的。</li><li>应用程序类加载器<br>加载完核心类库和扩展类，这时候就到了第三层，应用程序类加载器Application ClassLoader，这个类加载器你就可以理解成是加载我们写好的java代码的就可以了。</li><li>自定义类加载器<br>前面的三层就是基本的类加载器了，然后第四层是自定义类加载器，根据一些特殊的需求来自己定义类加载器加载我们的类。</li></ol><p>整体上类加载器就是这么的4层结构。很多小伙伴可能都听说过<strong>双亲委派机制</strong>，那么什么是<strong>双亲委派机制</strong>呢?</p><p>其实很好理解，就是当我们的类加载器要加载一个类的时候，它首先会委派给它的父亲去加载，但是如果它的父亲没找到就会把这个事交给他的孩子自己去完成了。</p><p>举个例子，假如我们的应用程序类加载器要加载一个类A，那么首先它会先回家找它老爸扩展类加载器，问问“老爸，你那有这个类A吗？”<br>然后扩展类加载器接到这个请求之后，同样也懒得处理，再去找它爷爷启动类加载器。<br>它爷爷找了一圈没找到类A，很生气，就对扩展类加载器说，“我这没有，你自己找去！”<br>然后扩展类加载器就灰溜溜的自己找了一圈，同样也没找到，这时候就找到应用类加载器了，说：“我这哪有你这个类A，这明明是你自己应该干的活，爱上哪找上哪找去，我不管了”。<br>这时候应用类加载器就只能自己去处理了，找了一圈发现找到了类A，就把它加载到jvm内存中了。</p><p><strong>验证</strong><br>jvm根据java规范，来校验你加载进来的class文件中的内容是否符合规范，如果不符合规范jvm是无法正常运行的。</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li><li>字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出威海虚拟机安全的事。</li><li>符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li></ol><p><strong>准备</strong><br><strong>准备阶段主要为类变量分配内存并设置初始值</strong><br>假设我们有一个类A，刚刚加载并通过了验证，那么就会进行准备工作。<br>这个准备工作其实就是给类A分配一定的内存空间，然后给里面的静态变量(static修饰的变量)也分配内存空间，并赋初始值。</p><p><strong>解析</strong></p><p>这个阶段干的事实际上是<strong>把符号引用替换为直接引用</strong>，这一过程网上有很多资料，还是比较复杂的，如果感兴趣小伙伴们可以自己查阅一下资料。</p><ul><li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</li><li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li></ul><p><strong>初始化</strong><br>在准备阶段，我们把类A的内存已经分配完了，那么初始化阶段要做些什么事呢？我们先看一下类A的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    private static String i&#x3D;System.getProperty(&quot;i&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备阶段我们只是给变量i分配了内存空间，并赋值了初始值，但是后边的System.getProperty(“i”)是不会执行的。<br>没错，这部分代码就是在初始化阶段执行的，另外静态代码块也会在这一阶段执行。<br>举个例子，比如我们新建一个对象new A()，此时就会触发从加载到初始化的全过程，把这个类准备好并创建一个实例对象。<br>    此外这里有一个规则，如果类A继承了类B，那么在初始化类A的时候，如果发现类B还没有初始化，会先初始化类B。</p><p><strong>扩展</strong><br>    小伙伴们想过没有，Tomcat也是用java开发的，那么它的类加载机制是什么样的呢，为什么就能支持jsp呢？<br>    其实它就是利用了自定义类加载器这一机制，自己自定义了很多类加载器<br>    Tomcat自定义了这么多的类加载器，用来加载它自己的核心类库，并且Tomcat是打破了双亲委派机制的，感兴趣的小伙伴可以自己去查资料了解一下，本篇文章长篇大论来聊Tomcat了。</p><hr><p><strong>java是解释运行的吗？</strong><br>不正确！</p><ol><li>Java源代码经过Javac编译成.class文件 </li><li>class文件经JVM解析或编译运行。 <ul><li>（1）解析:.class文件经过JVM内嵌的解析器解析执行。 </li><li>（2）编译:存在JIT编译器（Just In Time Compile<br>即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。 </li><li>（3）AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li></ul></li></ol><p>　　以 Oracle JDK提供的HotSpot虚拟机为例，在HotSpot虚拟机中，提供了两种编译模式：<strong>解释执行</strong> 和 <strong>即时编译（JIT，Just-In-Time）</strong>。解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码（上述提到的“编译执行”）。前者的优势在于不用等待，后者则在实际运行当中效率更高。</p><p>　即时编译存在的意义在于它是提高程序性能的重要手段之一。根据“二八定律”（即：百分之二十的代码占据百分之八十的系统资源），对于大部分不常用的代码，我们无需耗时间将之编译为机器码，而是采用解释执行的方式，用到就去逐条解释运行；对于一些仅占据小部分的热点代码（可认为是反复执行的重要代码），则可将之翻译为符合机器的机器码高效执行，提高程序的效率，此为运行时的即时编译。</p><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;谈谈你对Java平台的理解？“Java是解释执行”，这句话正确吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;★考点&quot;&gt;&lt;a href=&quot;#★考点&quot; class=&quot;headerlink&quot; title=&quot;★考点&quot;&gt;&lt;/a&gt;★考点&lt;/h3&gt;&lt;p&gt;题目是开放性的，</summary>
      
    
    
    
    <category term="基础" scheme="https://wulianling.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://wulianling.github.io/tags/java/"/>
    
    <category term="平台" scheme="https://wulianling.github.io/tags/%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试技巧</title>
    <link href="https://wulianling.github.io/2020/11/30/Interview-skills/"/>
    <id>https://wulianling.github.io/2020/11/30/Interview-skills/</id>
    <published>2020-11-30T01:24:24.000Z</published>
    <updated>2020-11-30T09:13:50.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="★如何面试"><a href="#★如何面试" class="headerlink" title="★如何面试"></a>★如何面试</h3><ul><li>提前准备</li><li>面试总结（录音）<ul><li>面试的时候问了我的问题</li><li>这些问题你怎么回答的</li><li>如果是自己的环境，你会不会回答的很好</li><li>自己面试后弱势在哪里，或者说技术薄弱点在哪里，补充起来，再面试</li></ul></li></ul><h3 id="★如何进行自我介绍？"><a href="#★如何进行自我介绍？" class="headerlink" title="★如何进行自我介绍？"></a>★如何进行自我介绍？</h3><p>基本信息—– 姓名，工作年限，家乡，教育背景(有优势就说，没有就不说)非常感谢面试官给我这次面试机会，下面我简单做个描述，您看下我的简历。</p><p>行业经验，陈述自己的项目（如果有跟公司相同背景的项目，优先说，如果没有，使用一个最熟练的项目）</p><ol><li>项目是干嘛的（简单，一两句话概述）</li><li>你在当前项目承担的主要职责.难点，遇到的问题提前说出来，自己的解决问题的能力</li><li>在描述项目的时候，如果能够带一些具体的数据会很好（电商，日活量，集群，qps）</li><li>面试官我的介绍大概这么多，您看您有什么问题想问的。</li></ol><p><font color="red">主导权：不要被面试官牵着鼻子走<br>面试的时候要自信，不管技术实力怎么样，干就完了。</font></p><h3 id="★如何陈述自己的项目？"><a href="#★如何陈述自己的项目？" class="headerlink" title="★如何陈述自己的项目？"></a>★如何陈述自己的项目？</h3><p>体现一个重要的点：你是项目的核心人员，参与了多个模块的设计开发<br>问题自己一个问题，看到自己的简历，你会问什么问题？10个？三个同学帮你问问题？</p><p><font color="red">总结：条理性。总分（总）的方式去表述项目，自己拿笔纸画一下项目的架构图或者数据流图</font></p><h3 id="★如何回答自己会的问题？"><a href="#★如何回答自己会的问题？" class="headerlink" title="★如何回答自己会的问题？"></a>★如何回答自己会的问题？</h3><p>按照总分的方式去回答问题：<br>先说明这个方案或者有的因公场景，以分条的方式去阐述细节<br>1、<br>2、<br>3、<br><font color="red">最好跟之前的项目经历挂钩，可以延伸到项目中具体的实现方案以及遇到的实际问题和解决方案<br>面试官，折腾个是我个人的理解，您看一下有什么问题，能帮我指导下？</font></p><h3 id="★如何回答自己不会的问题？"><a href="#★如何回答自己不会的问题？" class="headerlink" title="★如何回答自己不会的问题？"></a>★如何回答自己不会的问题？</h3><ol><li><p>了解一丢丢，能描述一点</p><ul><li>面试官，这个问题我自己私下研究过一点，没有深入研究过，我给您说一下自己的理解，你看对不对。。。。。说完了，您看有什么问题，帮我指正一下。</li></ul></li><li><p>完全没听过，扯也扯不不来</p><ul><li>不好意思，面试官，这个问题在我之前的项目和学习中都没有接触过，非常抱歉。这个虽然我不会，但是之前的技术都是自学的，我相信自己的自学能力，我对这个点比较迷茫，您能跟我说一下这个技术在<strong>咱们</strong>公司的技能栈的应用场景吗？ 在<strong>咱们</strong>公司的项目结构中有什么样的作用？您能跟我聊聊吗？</li></ul></li></ol><h3 id="★如何谈薪资？"><a href="#★如何谈薪资？" class="headerlink" title="★如何谈薪资？"></a>★如何谈薪资？</h3><p><strong>注：简历工资 写面议</strong></p><p>不要说薪资范围，千万不要说范围<br>要有一个心理预期， 现在15 ，你想要20，要薪水的时候，大概多3K左右。（具面试效果而定）</p><p>给不到，反问一句，您能给到我多少？</p><p>不好意思，这个虽然可能跟我的预期不太一样，但是通过接触，感觉，我相信能达到一些成长，我希望把我的力量发挥到最大</p><p>关于公司的所有福利待遇薪水如果有问题，只找hr,不要更技术关聊太多这些点</p><h3 id="★如何谈缺点？"><a href="#★如何谈缺点？" class="headerlink" title="★如何谈缺点？"></a>★如何谈缺点？</h3><p>不要真的去说缺点<br>优点歪着说？我这个很执着，遇到问题的时候必须要把这个点搞明白，搞透，所以有时候可能会浪费了自己的一点时间，我这个人太注意细节， 有些细节可能跟同事期望不一样，可能发生一些争论。</p><p>懒</p><h3 id="★如何说明自己的职业规划？"><a href="#★如何说明自己的职业规划？" class="headerlink" title="★如何说明自己的职业规划？"></a>★如何说明自己的职业规划？</h3><p>码农–&gt;程序员–&gt;中高级–&gt;项目领导–&gt;CTO（架构师）<br>码农：只做复制粘贴的工作，没有创新能力，有没有抽象能力，没有架构思维<br>程序员：应该具备自己的思维，应该有自己的独立思考能力</p><p>中途放弃？(技术)，很多人在公司环境的是偶慢慢会把自己的技术落下，<br>关注的是管理，业务，都是辅助功能，不是ADC</p><p>我相信公司的平台，在公司的平台下我能取得长足的进步，能发光发热</p><h3 id="★如何回答你有什么想问的？"><a href="#★如何回答你有什么想问的？" class="headerlink" title="★如何回答你有什么想问的？"></a>★如何回答你有什么想问的？</h3><p>意味着面试结束了<br>技术官：</p><ol><li>问公司的业务背景，技术体系：我之前了解到咱们公司是做XX技术解决方案的，<br>您能跟我说一下公司的主要技术架构或者技能栈吗？</li><li>如果我有幸能入职咱们公司，我是在您手下工作吗？</li><li>咱们告诉你有没有定期的技术培养，有没有技术分享会？<br>（不要提钱，不要提福利，不要提团队规模）</li></ol><p>HR：</p><ol><li>确定福利</li><li>确定公司的团队规模</li><li>能带着我在公司看看吗？（不一定可以）<br>总结：希望能维护好跟HR的关系，您能告诉我 我的面试结果吗，不管是够成功，希望你能给我一个确定的答复，非常开心认识您，希望能保持联系，希望之后还有合作机会。</li></ol><h3 id="★如何回答离职原因？"><a href="#★如何回答离职原因？" class="headerlink" title="★如何回答离职原因？"></a>★如何回答离职原因？</h3><p>切记不要说上家公司的坏话</p><ol><li>公司倒闭了（特定时间段）</li><li>发展受限（哪里受限了）</li></ol><p>（例子）苏州街工作，我女朋友在通州工作，我们一周只能见一次面，都在北京，<br>感觉在异地一样，上家公司太远了，实在没办法，所以只能离职。</p><p><strong>有句老话：</strong><br><strong>自古深情留不住，唯有套路得人心 :)</strong></p><hr><p><strong>但是注意一点，这不是套路，这是个人风格的问题，你慢慢会发现，这些总结是无往不利的，没必要在这些问题上花太多时间</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;★如何面试&quot;&gt;&lt;a href=&quot;#★如何面试&quot; class=&quot;headerlink&quot; title=&quot;★如何面试&quot;&gt;&lt;/a&gt;★如何面试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提前准备&lt;/li&gt;
&lt;li&gt;面试总结（录音）&lt;ul&gt;
&lt;li&gt;面试的时候问了我的问题&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://wulianling.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="技巧" scheme="https://wulianling.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
