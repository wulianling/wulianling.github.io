<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软考历程</title>
      <link href="2021/10/05/compute_soft_test_process/"/>
      <url>2021/10/05/compute_soft_test_process/</url>
      
        <content type="html"><![CDATA[<h3 id="我的软考之路"><a href="#我的软考之路" class="headerlink" title="我的软考之路"></a>我的软考之路</h3><blockquote><p>路漫漫其修远兮，吾将上下而求索</p></blockquote><h4 id="1-计算机组成与体系结构"><a href="#1-计算机组成与体系结构" class="headerlink" title="1. 计算机组成与体系结构"></a>1. <a href="%22%22">计算机组成与体系结构</a></h4><h4 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. <a href>操作系统</a></h4><h4 id="3-数据库系统"><a href="#3-数据库系统" class="headerlink" title="3. 数据库系统"></a>3. <a href>数据库系统</a></h4><h4 id="4-嵌入式系统"><a href="#4-嵌入式系统" class="headerlink" title="4. 嵌入式系统"></a>4. <a href>嵌入式系统</a></h4><h4 id="5-数据通信与计算机网络"><a href="#5-数据通信与计算机网络" class="headerlink" title="5. 数据通信与计算机网络"></a>5. <a href>数据通信与计算机网络</a></h4><h4 id="6-多媒体基础知识"><a href="#6-多媒体基础知识" class="headerlink" title="6. 多媒体基础知识"></a>6. <a href>多媒体基础知识</a></h4><h4 id="7-系统配置与性能评价"><a href="#7-系统配置与性能评价" class="headerlink" title="7. 系统配置与性能评价"></a>7. <a href>系统配置与性能评价</a></h4><h4 id="8-信息系统基础知识"><a href="#8-信息系统基础知识" class="headerlink" title="8. 信息系统基础知识"></a>8. <a href>信息系统基础知识</a></h4><h4 id="9-软件工程"><a href="#9-软件工程" class="headerlink" title="9. 软件工程"></a>9. <a href>软件工程</a></h4><h4 id="11-新技术应用"><a href="#11-新技术应用" class="headerlink" title="11. 新技术应用"></a>11. <a href>新技术应用</a></h4><h4 id="12-项目管理"><a href="#12-项目管理" class="headerlink" title="12. 项目管理"></a>12. <a href>项目管理</a></h4><h4 id="13-软件体系结构"><a href="#13-软件体系结构" class="headerlink" title="13. 软件体系结构"></a>13. <a href>软件体系结构</a></h4><h4 id="14-安全性知识"><a href="#14-安全性知识" class="headerlink" title="14. 安全性知识"></a>14. <a href>安全性知识</a></h4><h4 id="15-知识产权与法律法规"><a href="#15-知识产权与法律法规" class="headerlink" title="15. 知识产权与法律法规"></a>15. <a href>知识产权与法律法规</a></h4><h4 id="16-标准化知识"><a href="#16-标准化知识" class="headerlink" title="16. 标准化知识"></a>16. <a href>标准化知识</a></h4><h4 id="17-应用数学与经济管理"><a href="#17-应用数学与经济管理" class="headerlink" title="17. 应用数学与经济管理"></a>17. <a href>应用数学与经济管理</a></h4><h4 id="18-专业英语"><a href="#18-专业英语" class="headerlink" title="18. 专业英语"></a>18. <a href>专业英语</a></h4><h4 id="19-未完待续…"><a href="#19-未完待续…" class="headerlink" title="19. (未完待续…)"></a>19. (未完待续…)</h4>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about-time-thinking</title>
      <link href="2021/02/15/about-time-thinking/"/>
      <url>2021/02/15/about-time-thinking/</url>
      
        <content type="html"><![CDATA[<h3 id="时间的样子"><a href="#时间的样子" class="headerlink" title="时间的样子"></a>时间的样子</h3><p style="text-indent:2em">黎明前的黑暗，大年的第四天，我卧靠着床头，多日的假日生活除了吃和睡，没有别的必要的日常，幸福的些许枯燥，而时光飞快，十三天的假期，剩下三天了，今天的此时，已经睡醒了，清醒着，端着手机，也不知道看些什么东西，窗外已经有断断续续的鸡鸣声了，远远近近的，一只鸡认真严肃的在每一户人家窗前经过，给每一个人打鸣，天地间，这么认真对待时光，万年的历史长河中，一个个黑夜到白天，似乎自己没有睡眠，眼前飘着无形的时钟，它优雅的来回踱步，眼里看不见其他，只盯着时间，到了点，清一清喉咙，从肺里掏出恒古不变的卡带，塞进喉咙里，给世界一点声音，告诉天上的月色和星光，到点了，收一收光芒，休息去吧；</p><p style="text-indent:2em">窗外的钠灯下，奇怪的波纹，像风的痕迹，从左边吹过右边，走进窗前，抹去玻璃上的雾气，凑近看个究竟，缺什么也看不到，回来重新藏进被窝里，探出个脑袋，望向窗外，那轻柔有急促、纤细有繁密的时间的风，有吹了起来，却没有风的应有样子，因为他听不到一点点声响，只是不小心被我看见了；</p><p style="text-indent:2em">心里惊喜着，我居然看见了时间，赶紧用文字把它留下来，因为此时我瞥向窗外，它不见了，我想好好的描写它，乘我还记得它的样子， 却一个劲的勾勒其他..</p>]]></content>
      
      
      <categories>
          
          <category> 我有个一作家梦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比Hashtable、HashMap、TreeMap有什么不同？</title>
      <link href="2020/12/03/differ-between-with-Hashtable-HashMap-treeMap/"/>
      <url>2020/12/03/differ-between-with-Hashtable-HashMap-treeMap/</url>
      
        <content type="html"><![CDATA[<p><strong>对比Hashtable、HashMap、TreeMap有什么不同？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><ul><li>从各种数据结构、典型应用场景，到程序设计实现的技术考量，尤其是在Java8里，HashMap本身发生了非常大的变化，这些都是经常考察的方面。</li><li>理解Map相关类似整体结构，尤其是有序数据结构的一些要点。</li><li>从源码去分析HashMap的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响Map的性能，实践中如何取舍等。</li><li>理解树化改造的相关原理和改进原</li></ul><p><strong>重载equals方法时要遵守的通用约定–自反性,对称性,传递性，一致性，非空性</strong><br><img src="https://www.cnblogs.com/ttylinux/p/6539436.html" alt="重载equals方法时要遵守的通用约定--自反性,对称性,传递性，一致性，非空性"> </p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java反射机制，动态代理是基于什么原理？</title>
      <link href="2020/12/02/java-reflection-mechanism-and-dynamic-proxy/"/>
      <url>2020/12/02/java-reflection-mechanism-and-dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<p><strong>谈谈Java反射机制，动态代理是基于什么原理？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><ul><li>考察你对反射机制的了解和掌握程度。</li><li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li><li>JDK动态代理在设计和实现上与cglib等方式有什么不同，进而如何取舍？</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://www.zhihu.com/question/24304289">学习java应该如何理解反射？</a></p><p>静态代理和动态代理：</p><p>静态代理:<br>优点：<br>代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。</p><p>缺点：<br>1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p><p>2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。</p><p>动态代理：</p><p>根据如上的介绍，你会发现每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类<br>所以我们就会想办法可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理</p><p>两种代理简单对比下两种方式各自优势<br>JDK Proxy的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新以保证在新版Java上能够使用。</li><li>代码实现简单。<br>基于类似cglib框架的优势：</li><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似cglib动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 代理 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Java的字符串，String、StringBufer、StringBuilder有什么区别</title>
      <link href="2020/12/02/differ-betwen-String-StringBuffer-and-StringBuilder/"/>
      <url>2020/12/02/differ-betwen-String-StringBuffer-and-StringBuilder/</url>
      
        <content type="html"><![CDATA[<p><strong>理解Java的字符串，String、StringBufer、StringBuilder有什么区别？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。</p><p>如果继续深入，面试官可以从各种不同的角度考察，比如可以：</p><ul><li>通过String和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li><li>考察JVM对象缓存机制的理解以及如何良好地使用。</li><li>考察JVM优化Java代码的一些技巧。</li><li>String相关类的演进，比如Java 9中实现的巨大变化。</li></ul><ul><li>（1） 元素特性<br>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。 </li></ul><p>-（2）顺序特性<br>HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的 值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口 实现排序方式。 </p><p>-（3）初始化与增长方式<br>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。 扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。 </p><p>-（4）线程安全性<br>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低 下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞， 大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。 HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使 用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配 一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。 </p><p>(5)一段话HashMap<br>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时， 通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存 键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 （TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】垃圾回收</title>
      <link href="2020/12/01/java-gc/"/>
      <url>2020/12/01/java-gc/</url>
      
        <content type="html"><![CDATA[<p>本文主要摘自《深入理解Java虚拟机》，内容较多，尽量全面概括了 Java 垃圾回收机制、垃圾回收器以及内存分配策略等内容。了解 Java 垃圾回收之前，需要<a href="https://wulianling.github.io/2020/11/30/JAVA-memory-area-and-memory-model/">先了解 Java内存区域</a></p><h3 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h3><p><strong>垃圾回收主要关注 Java 堆</strong><br><img src="/2020/12/01/java-gc/jdk8-java-memory.png"><br>Java 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而 Java 堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p><h4 id="判断哪些对象需要被回收"><a href="#判断哪些对象需要被回收" class="headerlink" title="判断哪些对象需要被回收"></a>判断哪些对象需要被回收</h4><p>有以下两种方法：</p><ol><li>引用计数法<br>给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。</li><li>可达性分析算法<br>通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。<br><img src="/2020/12/01/java-gc/gc1.png"><br>在Java语言中，可作为 GC Roots 的对象包括下面几种：</li></ol><ul><li>a.虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>b.方法区中类静态属性引用的对象。</li><li>c. 方法区中常量引用的对象。</li><li>d. 本地方法栈中 JNI（Native方法）引用的对象</li></ul><p>作为 GC Roots 的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为 Roots，因此必须选取确定存活的引用类型对象。</p><p>GC 管理的区域是 Java 堆，虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。</p><p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。</p><h4 id="强、软、弱、虚引用"><a href="#强、软、弱、虚引用" class="headerlink" title="强、软、弱、虚引用"></a>强、软、弱、虚引用</h4><p>JDK1.2 以前，一个对象只有被引用和没有被引用两种状态。</p><p>后来，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><ol><li>强引用就是指在程序代码之中普遍存在的，类似”Object obj=new Object()”这类的引用，垃圾收集器永远不会回收存活的强引用对象。</li><li>软引用：还有用但并非必需的对象。在系统<strong>将要发生内存溢出异常之前</strong> ，将会把这些对象列进回收范围之中进行第二次回收。</li><li>弱引用也是用来描述非必需对象的，被弱引用关联的对象 <strong>只能生存到下一次垃圾收集发生之前</strong> 。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用是最弱的一种引用关系。 <strong>无法通过虚引用来取得一个对象实例</strong>。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><p><img src="/2020/12/01/java-gc/gc2.png"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li>如果对象在进行可达性分析后发现没有与<strong>GCRoots相连接的引用链</strong>，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。</li><li>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。</li><li>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去<strong>执行</strong>它。</li></ol><p>这里所谓的“<strong>执行</strong>”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 finalize() 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。</p><p>测试程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizerTest &#123;</span><br><span class="line">    public static FinalizerTest object;</span><br><span class="line">    public void isAlive() &#123;</span><br><span class="line">        System.out.println(&quot;I&#39;m alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;method finalize is running&quot;);</span><br><span class="line">        object &#x3D; this;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        object &#x3D; new FinalizerTest();</span><br><span class="line">        &#x2F;&#x2F; 第一次执行，finalize方法会自救</span><br><span class="line">        object &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (object !&#x3D; null) &#123;</span><br><span class="line">            object.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;I&#39;m dead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 第二次执行，finalize方法已经执行过</span><br><span class="line">        object &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (object !&#x3D; null) &#123;</span><br><span class="line">            object.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;I&#39;m dead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method finalize is running</span><br><span class="line">I&#39;m alive</span><br><span class="line">I&#39;m dead</span><br></pre></td></tr></table></figure><p>如果不重写 finalize()，输出将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m dead</span><br><span class="line">I&#39;m dead</span><br></pre></td></tr></table></figure><p>从执行结果可以看出：<br>第一次发生 GC 时，finalize() 方法的确执行了，并且在被回收之前成功逃脱；<br>第二次发生 GC 时，由于 finalize() 方法只会被 JVM 调用一次，object 被回收</p><p>值得注意的是，使用 finalize() 方法来“拯救”对象是不值得提倡的，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize() 能做的工作，使用 try-finally 或者其它方法都更适合、及时。</p><h4 id="Java-堆永久代的回收"><a href="#Java-堆永久代的回收" class="headerlink" title="Java 堆永久代的回收"></a>Java 堆永久代的回收</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><ol><li>回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做”abc”的，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li><strong>类需要同时满足下面 3 个条件才能算是“无用的类”：</strong></li></ol><ul><li>a. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>b. 加载该类的 ClassLoader 已经被回收。</li><li>c. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p>一共有 4 种：</p><ol><li>标记-清除算法</li><li>复制算法</li><li>标记整理算法</li><li>分代收集算法</li></ol><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它的主要不足有两个：</p><ol><li>效率问题，标记和清除两个过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p>标记—清除算法的执行过程如下图。<br><img src="/2020/12/01/java-gc/gc3.png"></p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><img src="/2020/12/01/java-gc/gc4.png"></p><p>现在的商业虚拟机都采用这种算法来回收新生代，IBM 研究指出新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。</p><p>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden:Survivor = 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（其中一块Survivor不可用），只有 10% 的内存会被“浪费”。</p><p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在 98% 的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。</p><p>内存的分配担保也一样，如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分配担保的内容，在本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下：<br><img src="/2020/12/01/java-gc/gc5.png"></p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。</p><p>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h4 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h4><p><strong>枚举根节点</strong></p><p>以可达性分析中从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><p>另外，可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须不可以出现分析过程中对象引用关系还在不断变化的情况，否则分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun将这件事情称为”Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</p><p>因此，目前的主流 Java 虚拟机使用的都是准确式 GC（即虚拟机可以知道内存中某个位置的数据具体是什么类型。），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。</p><p>在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录栈和寄存器中哪些位置是引用。这样， GC 在扫描时就可以直接得知这些信息了。</p><p><strong>安全点（Safepoint）</strong></p><p>在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。</p><p>实际上，HotSpot 也的确没有为每条指令都生成 OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC ，只有在到达安全点时才能暂停。</p><p>Safepoint 的选定既不能太少以致于 GC 过少，也不能过于频繁以致于过分增大运行时的负荷。</p><p>对于 Safepoint，另一个需要考虑的问题是如何在 GC 发生时让所有线程都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p><p>其中抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。</p><p>而主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><p><strong>安全区域（Safe Region）</strong></p><p>使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的Safepoint。但是，程序“不执行”的时候呢？</p><p>所谓的程序不执行就是没有分配 CPU 时间，典型的例子就是线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配 CPU 时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化。</strong></p><p>在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。这里讨论的收集器基于JDK 1.7 Update 14之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图所示<br><img src="/2020/12/01/java-gc/gc6.png"><br>上图展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析 CMS 和 G1 这两款相对复杂的收集器，了解它们的部分运作细节。</p><h5 id="Serial收集器（串行收集器）"><a href="#Serial收集器（串行收集器）" class="headerlink" title="Serial收集器（串行收集器）"></a>Serial收集器（串行收集器）</h5><p>Serial 收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机新生代收集的唯一选择。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p>“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了 Serial/Serial Old 收集器的运行过程。<br><img src="/2020/12/01/java-gc/gc7.png"><br>实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc8.png"><br>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器（并发收集器，后面有介绍）配合工作。</p><p>ParNew 收集器在单 CPU 的环境中不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。</p><p>当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（如 32 个)的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>注意，从 ParNew 收集器开始，后面还会接触到几款并发和并行的收集器。这里有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和 ParNew 都一样，那它有什么特别之处呢？<br>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。</p><p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是99% 。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p><p>MaxGCPauseMillis参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。</p><p>不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>GCTimeRatio 参数的值应当是一个 0 到 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99 ，就是允许最大 1%（即 1/（1+99））的垃圾收集时间。</p><p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。这两点都将在后面的内容中详细讲解。Serial Old 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc9.png"></p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。</p><p>原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（PS MarkSweep）收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。</p><p>由于老年代 Serial Old 收集器在服务端应用性能上的“拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。</p><p>直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。Parallel Old 收集器的工作过程如下图所示。</p><p><img src="/2020/12/01/java-gc/gc10.png"></p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含”Mark Sweep”）上就可以看出，CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。<br><img src="/2020/12/01/java-gc/gc11.png"></p><p>CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是 CMS 还远达不到完美的程度，它有以下 3 个明显的缺点：<br><strong>第一、导致吞吐量降低</strong>。CMS 收集器对 CPU 资源非常敏感。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p><p>CMS 默认启动的回收线程数是（CPU数量+3）/4，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如2个）时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。</p><p><strong>第二、CMS 收集器无法处理浮动垃圾（Floating Garbage）</strong>，可能出现”Concurrent Mode Failure”失败而导致另一次 Full GC（新生代和老年代同时回收） 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p><p>在 JDK 1.5 的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中，CMS 收集器的启动阈值已经提升至 92% 。</p><p>要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent ModeFailure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</p><p><strong>第三、产生空间碎片</strong>。 CMS 是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。</p><p>为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。</p><p><strong>并行与并发</strong>： G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p><p><strong>分代收集</strong>： 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</p><p><strong>空间整合</strong>： 与 CMS 的“标记—清理”算法不同，G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC 。</p><p><strong>可预测的停顿</strong>： 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</p><p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是Garbage-First名称的来由），保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 <strong>Remembered Set</strong> 来避免全堆扫描的。</p><p>G1 中每个Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol><p>G1 的前几个步骤的运作过程和 CMS 有很多相似之处。</p><p>初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p>并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p><p>而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。</p><p>最后在筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。</p><p><img src="/2020/12/01/java-gc/gc12.png"></p><h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>阅读 GC 日志是处理 Java 虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。</p><p>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的 GC 日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125:[GC[DefNew:3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]</span><br><span class="line">100.667:[Full GC[Tenured:0 K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm:2999K-＞2999K（21248K）]，0.0150007 secs][Times:user&#x3D;0.01 sys&#x3D;0.00，real&#x3D;0.02 secs]</span><br></pre></td></tr></table></figure><p>最前面的数字33.125： 和 100.667： 代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p><p>GC 日志开头的 [GC 和 [Full GC 说明了这次垃圾收集的停顿类型，而不是用来区分新生代 GC 还是老年代 GC 的。</p><p>如果有 Full ，说明这次 GC 是发生了 Stop-The-World 的，例如下面这段新生代收集器 ParNew 的日志也会出现 [Full GC（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。如果是调用 System.gc() 方法所触发的收集，那么在这里将显示 [Full GC（System）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736:[ParNew:261599K-＞261599K（261952K），0.0000288 secs]</span><br></pre></td></tr></table></figure><p>接下来的 [DefNew、[Tenured、[Perm 表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的，例如上面样例所使用的 Serial 收集器中的新生代名为 “Default New Generation”，所以显示的是 [DefNew。如果是 ParNew 收集器，新生代名称就会变为 [ParNew，意为 “Parallel New Generation”。如果采用 Parallel Scavenge 收集器，那它配套的新生代称为 PSYoungGen，老年代和永久代同理，名称也是由收集器决定的。</p><p>后面方括号内部的 <strong bgcolor="grey">3324K-＞152K（3712K）</strong>&gt;含义是<strong bgcolor="grey">GC 前该内存区域已使用容量 -＞ GC 后该内存区域已使用容量 （该内存区域总容量）</strong>。而在<strong bgcolor="grey">方括号之外的 3324K-＞152K（11904K）</strong> 表示 <strong bgcolor="grey">GC 前 Java 堆已使用容量 -＞ GC 后 Java 堆已使用容量 （Java 堆总容量）</strong>。</p><p>再往后，<strong bgcolor="grey">.0025925 secs </strong>表示该内存区域 GC 所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如<strong bgcolor="grey"> [Times:user=0.01 sys=0.00，real=0.02 secs] </strong>，这里面的 user、sys 和 real 与 Linux 的 time 命令所输出的时间含义一致，分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。</p><p>CPU 时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O、等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以读者看到 user 或 sys 时间超过 real 时间是完全正常的。</p><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p>JDK 1.7 中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，在表3-2中整理了这些参数供读者实践时参考。<br><img src="/2020/12/01/java-gc/gc13.png"><br><img src="/2020/12/01/java-gc/gc14.png"></p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p><img src="/2020/12/01/java-gc/gc15.png"></p><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。<br>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final int_1MB&#x3D;1024 * 1024；</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails</span><br><span class="line">         -XX:SurvivorRatio&#x3D;8</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static void testAllocation () &#123;</span><br><span class="line">            byte[] allocation1，allocation2，allocation3，allocation4；</span><br><span class="line">            allocation1 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation2 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation3 &#x3D; new byte[2 * _1MB]；</span><br><span class="line">            allocation4 &#x3D; new byte[4 * _1MB]；&#x2F;&#x2F;出现一次Minor GC</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC[DefNew:6651K-＞148K（9216K），0.0070106 secs]6651K-＞6292K（19456K），</span><br><span class="line">0.0070426 secs][Times:user&#x3D;0.00 sys&#x3D;0.00，real&#x3D;0.00 secs]</span><br><span class="line">Heap</span><br><span class="line">def new generation total 9216K,used 4326K[0x029d0000，0x033d0000，0x033d0000）</span><br><span class="line">eden space 8192K，51%used[0x029d0000，0x02de4828，0x031d0000）</span><br><span class="line">from space 1024K，14%used[0x032d0000，0x032f5370，0x033d0000）</span><br><span class="line">to space 1024K，0%used[0x031d0000，0x031d0000，0x032d0000）</span><br><span class="line">tenured generation total 10240K,used 6144K[0x033d0000，0x03dd0000，0x03dd0000）</span><br><span class="line">the space 10240K，60%used[0x033d0000，0x039d0030，0x039d0200，0x03dd0000）</span><br><span class="line">compacting perm gen total 12288K,used 2114K[0x03dd0000，0x049d0000，0x07dd0000）</span><br><span class="line">the space 12288K，17%used[0x03dd0000，0x03fe0998，0x03fe0a00，0x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure><p>上方代码的 <strong>testAllocation()</strong> 方法中，尝试分配 3 个 2MB 大小和 1 个 4MB 大小的对象，在运行时通过**-Xms20M、-Xmx20M、-Xmn10M<strong>这 3 个参数限制了 Java 堆大小为 20MB ，不可扩展，其中 10MB 分配给新生代，剩下的 10MB 分配给老年代。</strong>-XX:SurvivorRatio=8<strong>决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8:1，从输出的结果也可以清晰地看到 **eden space 8192K、from space 1024K、to space 1024K</strong> 的信息，新生代总可用空间为 9216KB（Eden区+1个Survivor区的总容量）。</p><p>执行 <strong>testAllocation()</strong> 中分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB ，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p><p>这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（Survivor 空间只有 1MB 大小），所以只好通过分配担保机制提前转移到老年代去。</p><p>这次 GC 结束后，4MB 的 allocation4 对象顺利分配在 Eden 中，因此程序执行完的结果是 Eden 占用 4MB（被allocation4占用），Survivor 空闲，老年代被占用 6MB（被allocation1、allocation2、allocation3占用）。通过 GC 日志可以证实这一点。</p><p><strong>Minor GC 和 Full GC 有什么不一样吗？</strong></p><ul><li>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代</strong></p><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（ byte[] 数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（特别是短命大对象，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int_1MB&#x3D;1024 * 1024；</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio&#x3D;8</span><br><span class="line">         *-XX:PretenureSizeThreshold&#x3D;3145728</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static void testPretenureSizeThreshold () &#123;</span><br><span class="line">            byte[] allocation；</span><br><span class="line">            allocation &#x3D; new byte[4 * _1MB]；&#x2F;&#x2F;直接分配在老年代中</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def new generation total 9216K,used 671K[0x029d0000，0x033d0000，0x033d0000）</span><br><span class="line">eden space 8192K，8%used[0x029d0000，0x02a77e98，0x031d0000）</span><br><span class="line">from space 1024K，0%used[0x031d0000，0x031d0000，0x032d0000）</span><br><span class="line">to space 1024K，0%used[0x032d0000，0x032d0000，0x033d0000）</span><br><span class="line">tenured generation total 10240K,used 4096K[0x033d0000，0x03dd0000，0x03dd0000）</span><br><span class="line">the space 10240K，40%used[0x033d0000，0x037d0010，0x037d0200，0x03dd0000）</span><br><span class="line">compacting perm gen total 12288K,used 2107K[0x03dd0000，0x049d0000，0x07dd0000）</span><br><span class="line">the space 12288K，17%used[0x03dd0000，0x03fdefd0，0x03fdf000，0x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure><p>执行以上代码中的 <strong>testPretenureSizeThreshold()</strong> 方法后，我们看到 Eden 空间几乎没有被使用，而老年代的 10MB 空间被使用了 40%，也就是 4MB 的 allocation 对象直接就分配在老年代中，这是因为 PretenureSizeThreshold 参数被设置为 3MB（就是 3145728，这个参数不能像 -Xmx 之类的参数一样直接写 3MB），因此超过 3MB 的对象都会直接在老年代进行分配。</p><p>注意 PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge 收集器不认识这个参数，Parallel Scavenge 收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p><p><strong>长期存活的对象将进入老年代</strong><br>虚拟机给每个对象定义了一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1 。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。</p><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，无须等到 MaxTenuringThreshold 中要求的年龄，同年对象达到 Survivor 空间的一半后，他们以及年龄大于他们的对象都将直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代<br>所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC ，否则将进行 Full GC 。</p><p>转载来源：<a href="https://www.cnblogs.com/czwbig/p/11127159.html">https://www.cnblogs.com/czwbig/p/11127159.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Java内存区域（运行时数据区域）和内存模型（JMM）</title>
      <link href="2020/11/30/JAVA-memory-area-and-memory-model/"/>
      <url>2020/11/30/JAVA-memory-area-and-memory-model/</url>
      
        <content type="html"><![CDATA[<p>Java 内存区域和内存模型是不一样的东西，内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。</p><p>而内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式，如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。</p><h3 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h3><p>众所周知，Java 虚拟机有自动内存管理机制，如果出现内存泄漏和溢出方面的问题，排查错误就必须要了解虚拟机是怎样使用内存的。<br>下图是 JDK8 之后的 JVM 内存布局。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/jdk8-java-memory.png"></p><p>JDK8 之前的内存区域图如下:<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/before-jkk8-java-memory.png"></p><p>在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 java.lang.OutOfMemoryError: PermGen ，为此我们不得不对虚拟机做调优。<br>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因:</p><ul><li><ol><li>由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li></ol></li><li><ol start="2"><li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。<br>根据上面的各种原因，PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。</li></ol></li></ul><blockquote><p>引用自<a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/">https://www.sczyh30.com/posts/Java/jvm-metaspace/</a></p></blockquote><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。</p><p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是<strong>线程私有</strong>的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>在活动线程中，只有位栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/stacks.png"></p><h5 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表"></a>1.局部变量表</h5><p>局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法<strong>，则在 index[0] 位置上存储的是方法所属对象的实例引用</strong>，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。</p><p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p><h5 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2.操作栈"></a>2.操作栈</h5><p>操作栈是个初始状态为空的<strong>桶式结构栈</strong>。在方法执行过程中， 会有各种指令往<br>栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎， 其中的栈指的就是操<br>作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。</p><p><strong>i++ 和 ++i 的区别：</strong></p><ol><li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li><li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li></ol><p>之前之所以说 i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。</p><h5 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h5><p>每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接</p><h5 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h5><p>方法执行时有两种退出情况：</p><ol><li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；</li><li>异常退出。</li></ol><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ol><li>返回值压入上层调用栈帧。</li><li>异常信息抛给能够处理的栈帧。</li><li>PC计数器指向方法调用后的下一条指令。</li></ol><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><p>线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。本地方法可以通过<br><strong>JNI(Java Native Interface)</strong> 来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。 当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对内存不足的情况，本地方法栈还是会抛出 nativeheapOutOfMemory。</p><p><strong>JNI</strong> 类本地方法最著名的应该是 System.currentTimeMillis() ，JNI使 Java 深度使用操作系统的特性功能，复用非 Java 代码。 但是在项目过程中， 如果大量使用其他语言来实现 JNI , 就会丧失跨平台特性。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有<strong>线程共享的一块内存区域</strong>，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p><p>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个<strong>线程共享的内存区域</strong>，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然<br>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><p><strong>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</strong></p><p>为什么要使用元空间取代永久代的实现？</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，<br>太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>将 HotSpot 与 JRockit 合二为一。</li></ol><p><strong>运行时常量池</strong></p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>直接内存</strong></p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。</p><p>在 JDK 1.4 中新加入了 NIO，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。<br><img src="/2020/11/30/JAVA-memory-area-and-memory-model/java-memory-area.png"></p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量（堆内存中的实例域，静态域和数组元素）来完成隐式通信。<br>Java 内存模型（JMM）控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。</p><h4 id="计算机高速缓存和缓存一致性"><a href="#计算机高速缓存和缓存一致性" class="headerlink" title="计算机高速缓存和缓存一致性"></a>计算机高速缓存和缓存一致性</h4><p>计算机在高速的 CPU 和相对低速的存储设备之间使用高速缓存，作为内存和处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。</p><p>在多处理器的系统中(或者单处理器多核的系统)，每个处理器内核都有自己的高速缓存，它们有共享同一主内存(Main Memory)。</p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><p>为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。</p><p><a href="cache1.pag"></a></p><h4 id="JVM主内存与工作内存"><a href="#JVM主内存与工作内存" class="headerlink" title="JVM主内存与工作内存"></a>JVM主内存与工作内存</h4><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（线程共享的变量）存储到内存和从内存中取出变量这样底层细节。</p><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p>这里的工作内存是 JMM 的一个抽象概念，也叫本地内存，其存储了该线程以读 / 写共享变量的副本。</p><p><strong>就像每个处理器内核拥有私有的高速缓存，JMM 中每个线程拥有私有的本地内存。</strong></p><p>不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行，一是通过消息传递，二是共享内存。Java 线程间的通信采用的是共享内存方式，线程、主内存和工作内存的交互关系如下图所示：<br><a href="cache2.pag"></a></p><p>这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</p><h4 id="重排序和happens-before规则"><a href="#重排序和happens-before规则" class="headerlink" title="重排序和happens-before规则"></a>重排序和happens-before规则</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><a href="cache3.pag"></a></p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入<strong>内存屏障</strong>（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。</p><p><strong>happens-before</strong></p><p>从 JDK5 开始，java 内存模型提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。</p><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p><strong>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong></p><p>如果 A happens-before B，那么 Java 内存模型将向程序员保证—— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。<br>重要的 happens-before 规则如下：</p><ol><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ol><p>下图是 happens-before 与 JMM 的关系<br><a href="happens-before.png"></a></p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile 可以说是 JVM 提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：</p><ol><li><p><strong>保证此变量对所有线程的可见性</strong>。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。<br>注意，volatile 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。而 synchronized 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得线程安全的。</p></li><li><p><strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p></li></ol><p>转载来源：<a href="https://www.cnblogs.com/czwbig/p/11127124.html">https://www.cnblogs.com/czwbig/p/11127124.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈fnal、fnally、 fnalize有什么不同？</title>
      <link href="2020/11/30/what-differ-about-final-finally-finalize/"/>
      <url>2020/11/30/what-differ-about-final-finally-finalize/</url>
      
        <content type="html"><![CDATA[<p><strong>谈谈fnal、fnally、 fnalize有什么不同？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察你对性能、并发、对象生命周期或垃圾 收集基本过程等方面的理解。</p><p><strong>final</strong></p><ul><li>我们可以将方法或者类声明为fnal，这样就可以明确告知别人，这些行为是不许修改的。</li><li>使用fnal修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成fnal</li><li>fnal变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值fnal变量，有利于减少额外的同步开 销，也可以省去一些防御性拷贝的必要。</li></ul><p><strong>finally</strong><br>对于fnally，明确知道怎么使用就足够了</p><p>特例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; do something  Sysem.exit(1); </span><br><span class="line">&#125; fnally&#123;  </span><br><span class="line">Sysem.out.println(“Print from fnally”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面fnally里面的代码可不会被执行的哦</p><p><strong>finalize</strong><br>finalize()是Object中的方法，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，，在Java 9中，甚至明确将Object.fnalize()标记为deprecated！如果没有特别的原因，不要实 现fnalize方法，也不要指望利用它来进行资源回收</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><ol><li><strong>注意，final 不是immutable！</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fnal Lis&lt;String&gt; srLis &#x3D; new ArrayLis&lt;&gt;(); </span><br><span class="line">srLis.add(&quot;Hello&quot;); srLis.add(&quot;world&quot;);  </span><br><span class="line"> Lis&lt;String&gt; unmodifableStrLis &#x3D; Lis.of(&quot;hello&quot;, &quot;world&quot;); </span><br><span class="line"> unmodifableStrLis.add(&quot;again&quot;);</span><br></pre></td></tr></table></figure>在上面这个例子中，List.of方法创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。在上面这个例子中，List.of方法创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。</li></ol><p>Immutable在很多场景是非常棒的选择，某种意义上说，Java语言目前并没有原生的不可变支持，如果要实现immutable的类，我们需要做到：</p><ul><li>将class自身声明为fnal，这样别人就不能扩展来绕过限制了。</li><li>将所有成员变量定义为private和fnal，并且不要实现setter方法。</li><li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li><li>如果确实需要实现getter方法，或者其他可能会返回内部状态的方法，使用copy-on-write原则，创建私有的copy。</li></ul><p><strong>copy-on-write原则</strong>，即写时复制。其核心思想是，有线程使用容器中的数据时，<strong>如果是写入</strong>，则复制出一个新容器，修改新容器中的数据后，再将引用指向新容器。<strong>如果是读操作</strong>则正常读引用地址中的容器数据。这里需要注意的是，复制新容器时底层通过copyof()方法来实现的，这是一个深层复制方法，即新容器是一个新的对象，在堆中有自己的内存区域，操作新容器不会影响旧容器，当然这也会增加内存开销。所以在复制的时候也加了锁，否则多线程会复制出多个对象占用内存，很容易导致OOM。</p><ol start="2"><li><strong>fnalize真的那么不堪？</strong><br>fnalize是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？<br>fnalize被设计成在对象被垃圾收集前调用，这就意味着实现了fnalize方法的对象是个“特殊公民”，JVM要对它进行额外处理。fnalize本质上成为了快速回收的阻碍者，可能 导致你的对象经过多个垃圾收集周期才能被回收。</li><li><strong>有什么机制可以替换fnalize吗？</strong><br>Java平台目前在逐步使用java.lang.ref.Cleaner来替换掉原有的fnalize实现。Cleaner的实现利用了幻象引用（PhantomReference），这是一种常见的所谓post-mortem清理 机制。我会在后面的专栏系统介绍Java的各种引用，利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的 资源），它比fnalize更加轻量、更加可靠。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CleaningExample implements AutoCloseable &#123;</span><br><span class="line">&#x2F;&#x2F; A cleaner, preferably one shared within a library</span><br><span class="line">    private satic fnal Cleaner cleaner &#x3D; &lt;cleaner&gt;;</span><br><span class="line">    satic class State implements Runnable &#123;</span><br><span class="line">        State(...) &#123;</span><br><span class="line">        &#x2F;&#x2F; initialize State needed for cleaning action</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; cleanup action accessing State, executed at mos once</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private fnal State;</span><br><span class="line">    private fnal Cleaner.Cleanable cleanable</span><br><span class="line">    public CleaningExample() &#123;</span><br><span class="line">        this.sate &#x3D; new State(...);</span><br><span class="line">        this.cleanable &#x3D; cleaner.regiser(this, sate);</span><br><span class="line">    &#125;</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>实现AutoCloseable 重写close方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exception和Error有什么区别？</title>
      <link href="2020/11/30/what-differ-about-Exception-and-error/"/>
      <url>2020/11/30/what-differ-about-Exception-and-error/</url>
      
        <content type="html"><![CDATA[<p><strong>请对比Exception和Error，另外，运行时异常与一般异常有什么区别？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>分析Exception和Error的区别，是从概念角度考察了java处理机制。总得来说，还处于理解的层面</p><h3 id="一、异常机制的概述"><a href="#一、异常机制的概述" class="headerlink" title="一、异常机制的概述"></a>一、异常机制的概述</h3><p>异常机制是指当<strong>程序出现错误</strong>后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。</p><p> 程序错误分为三种：1.编译错误；2.运行时错误；3.逻辑错误。<br>1）<strong>编译错误</strong>是因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置，这个也是大家在刚接触编程语言最常遇到的问题。<br>2）<strong>运行时错误</strong>是因为程序在执行时，运行环境发现了不能执行的操作。<br>3）<strong>逻辑错误</strong>是因为程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制。</p><h3 id="二、异常的结构"><a href="#二、异常的结构" class="headerlink" title="二、异常的结构"></a>二、异常的结构</h3><p> 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p><p> <img src="/2020/11/30/what-differ-about-Exception-and-error/throwable.png"></p><p> <strong>Throwable：</strong><br>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理。</p><p>**Error（错误）:**是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 </p><p><strong>Exception（异常）</strong>分两大类：运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。<br>  1.<strong>运行时异常</strong>：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br>  2.<strong>非运行时异常 （编译异常）</strong>：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><ol><li><p><strong>可查异常（编译器要求必须处置的异常）：</strong><br>正确的程序在运行中，很容易出现的、情理可容的异常状况。除了Exception中的RuntimeException及RuntimeException的子类以外，其他的Exception类及其子类(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p></li><li><p><strong>不可查异常(编译器不要求强制处置的异常):</strong><br>包括运行时异常（RuntimeException与其子类）和错误（Error）。RuntimeException表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</p></li></ol><h3 id="三、异常处理的机制"><a href="#三、异常处理的机制" class="headerlink" title="三、异常处理的机制"></a>三、异常处理的机制</h3><p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><ol><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。详细信息请查看《<a href="https://blog.csdn.net/qq_29229567/article/details/89397648">简述throw-throws异常抛出</a>》。</li><li>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。详细信息请查看《<a href="https://blog.csdn.net/qq_29229567/article/details/87277744">Java：简述try-catch-finally异常捕获</a>》。</li></ol><h3 id="四、异常处理原则"><a href="#四、异常处理原则" class="headerlink" title="四、异常处理原则"></a>四、异常处理原则</h3><ol><li><strong>尽量不要粗活蕾西Ex学测评题欧尼这样的通用异常</strong></li><li><strong>不要生吞异常</strong></li><li><strong>throw early，catch late</strong><br>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处 理，可以选择保留原有异常的cause信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</li></ol><h3 id="五、性能角度下的异常处理机制"><a href="#五、性能角度下的异常处理机制" class="headerlink" title="五、性能角度下的异常处理机制"></a>五、性能角度下的异常处理机制</h3><ul><li>try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同 时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li>Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><h3 id="六、相关的问题"><a href="#六、相关的问题" class="headerlink" title="六、相关的问题"></a>六、相关的问题</h3><ol><li><p><strong>为什么要创建自己的异常？</strong><br>答：当Java内置的异常都不能明确的说明异常情况的时候，需要创建自己的异常。</p></li><li><p><strong>应该在声明方法抛出异常还是在方法中捕获异常？</strong><br>答：捕捉并处理知道如何处理的异常，而抛出不知道如何处理的异常。</p></li><li><p><strong>ClassNotFoundException和NoClassDefFoundError的区别?</strong><br>答：　ClassNotFoundException是一个检查异常。从类继承层次上来看，ClassNotFoundException是从Exception继承的，所以ClassNotFoundException是一个检查异常。<br><img src="/2020/11/30/what-differ-about-Exception-and-error/ClassNotFoundException.png"><br>NoClassDefFoundError异常，看命名后缀是一个Error。从类继承层次上看，NoClassDefFoundError是从Error继承的。和ClassNotFoundException相比，明显的一个区别是，NoClassDefFoundError并不需要应用程序去关心catch的问题。<br><img src="/2020/11/30/what-differ-about-Exception-and-error/NoClassDefFoundError.png"></p></li></ol><p><strong>总结</strong></p><table style>    <tr>        <td style="text-align:center">ClassNotFoundException</td>        <td style="text-align:center">NoClassDefFoundError</td>    </tr>    <tr>        <td>从java.lang.Exception继承，是一个Exception类型</td>        <td>从java.lang.Error继承，是一个Error类型</td>    </tr>    <tr>        <td>当动态加载Class的时候找不到类会抛出该异常</td>        <td>当编译成功以后执行过程中Class找不到导致抛出该错误</td>    </tr>     <tr>        <td>一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出</td>        <td>由JVM的运行时系统抛出</td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java平台的理解</title>
      <link href="2020/11/30/Understanding-of-Java-platform/"/>
      <url>2020/11/30/Understanding-of-Java-platform/</url>
      
        <content type="html"><![CDATA[<p><strong>谈谈你对Java平台的理解？“Java是解释执行”，这句话正确吗？</strong></p><h3 id="★考点"><a href="#★考点" class="headerlink" title="★考点"></a>★考点</h3><p>题目是开放性的，往往考察的是多个方面，比如：</p><ol><li>基础知识理解是否很清晰</li><li>是否掌握Java平台的主要模块和运行原理等</li></ol><p>你需要尽量表现出自己的思维升入并系统化，java知识理解的也比较拳迷看，一定要避免让面试官觉得你是一个“知其然不知其所以然”的人.</p><p style="text-indent:2em">    对于java平台的理解，可以从很多方面简明扼要的谈一下，例如：<ol><li>java的特性，包括泛型 、Lambda等语言特性</li><li>基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。</li><li>或者谈谈JVM的一些基础概念和机制，比如JAVA的类加载机制，常用版本内嵌的Class-Loader，例如Bootstrap、Application和Exception Class-loader；类加载的大只过程：加载、验证、连接、初始化；自定义Class-Loader等。还有垃圾收集的基本原理，最常见的垃圾收集机制，如SerialGC、ParallelGC，CMS、G1等</li></ol></p><h3 id="★学习足迹"><a href="#★学习足迹" class="headerlink" title="★学习足迹"></a>★学习足迹</h3><h2 id="JAVA代码的运行流程"><a href="#JAVA代码的运行流程" class="headerlink" title="JAVA代码的运行流程"></a>JAVA代码的运行流程</h2><p style="text-indent:2em">我们编写的代码都是在java文件中编写的，然后会编译成class字节码文件。当我们使用到哪个类的时候就会通过类加载器把class字节码文件中的类加载到jvm内存中，然后就是在jvm内存中运行我们的代码了。类加载器是如何把类加载到jvm内存中的，小伙伴们有考虑过吗？</p><h2 id="JVM什么时候加载类"><a href="#JVM什么时候加载类" class="headerlink" title="JVM什么时候加载类"></a>JVM什么时候加载类</h2><p style="text-indent:2em">一个类的加载过程会经历如下的几个过程：</p><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong></p><p><strong>加载</strong></p><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p><p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p><p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p><p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p><p>jvm是什么时候去加载类的呢？<br>程序的入口，具有main方法的类，肯定是最开始的时候就加载到jvm中了。<br>jvm是通过什么方式对类进行加载的呢？<br>就是类加载器。</p><p><strong>jvm的类加载器总体上可以分成4层:</strong></p><ol><li>动类加载器<br> 首先就是jvm启动的第一道关口，启动类加载器Bootstrap ClassLoader，它主要是加载java的核心类。<br>相信大家都知道，无论是什么环节下运行java程序，都是要安装jvm虚拟机环境的，而在这个环境的目录中是有一个lib文件夹的，这个文件下就是java最核心的类库，支撑着java系统的运行.<br> 所以一旦jvm启动，那么首先就会通过启动类加载器去加载lib文件夹下的核心类库。</li><li>扩展类加载器<br> 然后我们就到了第二层，扩展类加载器Extension ClassLoader，这个类加载器其实与启动类加载器是类似的。<br>在我们的jvm虚拟机环境目录下，是有一个lib/ext的文件夹的，这里面的类就是java运行环境的一些扩展类，这些扩展类就是在jvm启动后，通过扩展类加载器进行加载的。</li><li>应用程序类加载器<br>加载完核心类库和扩展类，这时候就到了第三层，应用程序类加载器Application ClassLoader，这个类加载器你就可以理解成是加载我们写好的java代码的就可以了。</li><li>自定义类加载器<br>前面的三层就是基本的类加载器了，然后第四层是自定义类加载器，根据一些特殊的需求来自己定义类加载器加载我们的类。</li></ol><p>整体上类加载器就是这么的4层结构。很多小伙伴可能都听说过<strong>双亲委派机制</strong>，那么什么是<strong>双亲委派机制</strong>呢?</p><p>其实很好理解，就是当我们的类加载器要加载一个类的时候，它首先会委派给它的父亲去加载，但是如果它的父亲没找到就会把这个事交给他的孩子自己去完成了。</p><p>举个例子，假如我们的应用程序类加载器要加载一个类A，那么首先它会先回家找它老爸扩展类加载器，问问“老爸，你那有这个类A吗？”<br>然后扩展类加载器接到这个请求之后，同样也懒得处理，再去找它爷爷启动类加载器。<br>它爷爷找了一圈没找到类A，很生气，就对扩展类加载器说，“我这没有，你自己找去！”<br>然后扩展类加载器就灰溜溜的自己找了一圈，同样也没找到，这时候就找到应用类加载器了，说：“我这哪有你这个类A，这明明是你自己应该干的活，爱上哪找上哪找去，我不管了”。<br>这时候应用类加载器就只能自己去处理了，找了一圈发现找到了类A，就把它加载到jvm内存中了。</p><p><strong>验证</strong><br>jvm根据java规范，来校验你加载进来的class文件中的内容是否符合规范，如果不符合规范jvm是无法正常运行的。</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li><li>字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出威海虚拟机安全的事。</li><li>符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li></ol><p><strong>准备</strong><br><strong>准备阶段主要为类变量分配内存并设置初始值</strong><br>假设我们有一个类A，刚刚加载并通过了验证，那么就会进行准备工作。<br>这个准备工作其实就是给类A分配一定的内存空间，然后给里面的静态变量(static修饰的变量)也分配内存空间，并赋初始值。</p><p><strong>解析</strong></p><p>这个阶段干的事实际上是<strong>把符号引用替换为直接引用</strong>，这一过程网上有很多资料，还是比较复杂的，如果感兴趣小伙伴们可以自己查阅一下资料。</p><ul><li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</li><li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li></ul><p><strong>初始化</strong><br>在准备阶段，我们把类A的内存已经分配完了，那么初始化阶段要做些什么事呢？我们先看一下类A的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    private static String i&#x3D;System.getProperty(&quot;i&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备阶段我们只是给变量i分配了内存空间，并赋值了初始值，但是后边的System.getProperty(“i”)是不会执行的。<br>没错，这部分代码就是在初始化阶段执行的，另外静态代码块也会在这一阶段执行。<br>举个例子，比如我们新建一个对象new A()，此时就会触发从加载到初始化的全过程，把这个类准备好并创建一个实例对象。<br>    此外这里有一个规则，如果类A继承了类B，那么在初始化类A的时候，如果发现类B还没有初始化，会先初始化类B。</p><p><strong>扩展</strong><br>    小伙伴们想过没有，Tomcat也是用java开发的，那么它的类加载机制是什么样的呢，为什么就能支持jsp呢？<br>    其实它就是利用了自定义类加载器这一机制，自己自定义了很多类加载器<br>    Tomcat自定义了这么多的类加载器，用来加载它自己的核心类库，并且Tomcat是打破了双亲委派机制的，感兴趣的小伙伴可以自己去查资料了解一下，本篇文章长篇大论来聊Tomcat了。</p><hr><p><strong>java是解释运行的吗？</strong><br>不正确！</p><ol><li>Java源代码经过Javac编译成.class文件 </li><li>class文件经JVM解析或编译运行。 <ul><li>（1）解析:.class文件经过JVM内嵌的解析器解析执行。 </li><li>（2）编译:存在JIT编译器（Just In Time Compile<br>即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。 </li><li>（3）AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li></ul></li></ol><p>　　以 Oracle JDK提供的HotSpot虚拟机为例，在HotSpot虚拟机中，提供了两种编译模式：<strong>解释执行</strong> 和 <strong>即时编译（JIT，Just-In-Time）</strong>。解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码（上述提到的“编译执行”）。前者的优势在于不用等待，后者则在实际运行当中效率更高。</p><p>　即时编译存在的意义在于它是提高程序性能的重要手段之一。根据“二八定律”（即：百分之二十的代码占据百分之八十的系统资源），对于大部分不常用的代码，我们无需耗时间将之编译为机器码，而是采用解释执行的方式，用到就去逐条解释运行；对于一些仅占据小部分的热点代码（可认为是反复执行的重要代码），则可将之翻译为符合机器的机器码高效执行，提高程序的效率，此为运行时的即时编译。</p><p></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员面试技巧</title>
      <link href="2020/11/30/Interview-skills/"/>
      <url>2020/11/30/Interview-skills/</url>
      
        <content type="html"><![CDATA[<h3 id="★如何面试"><a href="#★如何面试" class="headerlink" title="★如何面试"></a>★如何面试</h3><ul><li>提前准备</li><li>面试总结（录音）<ul><li>面试的时候问了我的问题</li><li>这些问题你怎么回答的</li><li>如果是自己的环境，你会不会回答的很好</li><li>自己面试后弱势在哪里，或者说技术薄弱点在哪里，补充起来，再面试</li></ul></li></ul><h3 id="★如何进行自我介绍？"><a href="#★如何进行自我介绍？" class="headerlink" title="★如何进行自我介绍？"></a>★如何进行自我介绍？</h3><p>基本信息—– 姓名，工作年限，家乡，教育背景(有优势就说，没有就不说)非常感谢面试官给我这次面试机会，下面我简单做个描述，您看下我的简历。</p><p>行业经验，陈述自己的项目（如果有跟公司相同背景的项目，优先说，如果没有，使用一个最熟练的项目）</p><ol><li>项目是干嘛的（简单，一两句话概述）</li><li>你在当前项目承担的主要职责.难点，遇到的问题提前说出来，自己的解决问题的能力</li><li>在描述项目的时候，如果能够带一些具体的数据会很好（电商，日活量，集群，qps）</li><li>面试官我的介绍大概这么多，您看您有什么问题想问的。</li></ol><p><font color="red">主导权：不要被面试官牵着鼻子走<br>面试的时候要自信，不管技术实力怎么样，干就完了。</font></p><h3 id="★如何陈述自己的项目？"><a href="#★如何陈述自己的项目？" class="headerlink" title="★如何陈述自己的项目？"></a>★如何陈述自己的项目？</h3><p>体现一个重要的点：你是项目的核心人员，参与了多个模块的设计开发<br>问题自己一个问题，看到自己的简历，你会问什么问题？10个？三个同学帮你问问题？</p><p><font color="red">总结：条理性。总分（总）的方式去表述项目，自己拿笔纸画一下项目的架构图或者数据流图</font></p><h3 id="★如何回答自己会的问题？"><a href="#★如何回答自己会的问题？" class="headerlink" title="★如何回答自己会的问题？"></a>★如何回答自己会的问题？</h3><p>按照总分的方式去回答问题：<br>先说明这个方案或者有的因公场景，以分条的方式去阐述细节<br>1、<br>2、<br>3、<br><font color="red">最好跟之前的项目经历挂钩，可以延伸到项目中具体的实现方案以及遇到的实际问题和解决方案<br>面试官，折腾个是我个人的理解，您看一下有什么问题，能帮我指导下？</font></p><h3 id="★如何回答自己不会的问题？"><a href="#★如何回答自己不会的问题？" class="headerlink" title="★如何回答自己不会的问题？"></a>★如何回答自己不会的问题？</h3><ol><li><p>了解一丢丢，能描述一点</p><ul><li>面试官，这个问题我自己私下研究过一点，没有深入研究过，我给您说一下自己的理解，你看对不对。。。。。说完了，您看有什么问题，帮我指正一下。</li></ul></li><li><p>完全没听过，扯也扯不不来</p><ul><li>不好意思，面试官，这个问题在我之前的项目和学习中都没有接触过，非常抱歉。这个虽然我不会，但是之前的技术都是自学的，我相信自己的自学能力，我对这个点比较迷茫，您能跟我说一下这个技术在<strong>咱们</strong>公司的技能栈的应用场景吗？ 在<strong>咱们</strong>公司的项目结构中有什么样的作用？您能跟我聊聊吗？</li></ul></li></ol><h3 id="★如何谈薪资？"><a href="#★如何谈薪资？" class="headerlink" title="★如何谈薪资？"></a>★如何谈薪资？</h3><p><strong>注：简历工资 写面议</strong></p><p>不要说薪资范围，千万不要说范围<br>要有一个心理预期， 现在15 ，你想要20，要薪水的时候，大概多3K左右。（具面试效果而定）</p><p>给不到，反问一句，您能给到我多少？</p><p>不好意思，这个虽然可能跟我的预期不太一样，但是通过接触，感觉，我相信能达到一些成长，我希望把我的力量发挥到最大</p><p>关于公司的所有福利待遇薪水如果有问题，只找hr,不要更技术关聊太多这些点</p><h3 id="★如何谈缺点？"><a href="#★如何谈缺点？" class="headerlink" title="★如何谈缺点？"></a>★如何谈缺点？</h3><p>不要真的去说缺点<br>优点歪着说？我这个很执着，遇到问题的时候必须要把这个点搞明白，搞透，所以有时候可能会浪费了自己的一点时间，我这个人太注意细节， 有些细节可能跟同事期望不一样，可能发生一些争论。</p><p>懒</p><h3 id="★如何说明自己的职业规划？"><a href="#★如何说明自己的职业规划？" class="headerlink" title="★如何说明自己的职业规划？"></a>★如何说明自己的职业规划？</h3><p>码农–&gt;程序员–&gt;中高级–&gt;项目领导–&gt;CTO（架构师）<br>码农：只做复制粘贴的工作，没有创新能力，有没有抽象能力，没有架构思维<br>程序员：应该具备自己的思维，应该有自己的独立思考能力</p><p>中途放弃？(技术)，很多人在公司环境的是偶慢慢会把自己的技术落下，<br>关注的是管理，业务，都是辅助功能，不是ADC</p><p>我相信公司的平台，在公司的平台下我能取得长足的进步，能发光发热</p><h3 id="★如何回答你有什么想问的？"><a href="#★如何回答你有什么想问的？" class="headerlink" title="★如何回答你有什么想问的？"></a>★如何回答你有什么想问的？</h3><p>意味着面试结束了<br>技术官：</p><ol><li>问公司的业务背景，技术体系：我之前了解到咱们公司是做XX技术解决方案的，<br>您能跟我说一下公司的主要技术架构或者技能栈吗？</li><li>如果我有幸能入职咱们公司，我是在您手下工作吗？</li><li>咱们告诉你有没有定期的技术培养，有没有技术分享会？<br>（不要提钱，不要提福利，不要提团队规模）</li></ol><p>HR：</p><ol><li>确定福利</li><li>确定公司的团队规模</li><li>能带着我在公司看看吗？（不一定可以）<br>总结：希望能维护好跟HR的关系，您能告诉我 我的面试结果吗，不管是够成功，希望你能给我一个确定的答复，非常开心认识您，希望能保持联系，希望之后还有合作机会。</li></ol><h3 id="★如何回答离职原因？"><a href="#★如何回答离职原因？" class="headerlink" title="★如何回答离职原因？"></a>★如何回答离职原因？</h3><p>切记不要说上家公司的坏话</p><ol><li>公司倒闭了（特定时间段）</li><li>发展受限（哪里受限了）</li></ol><p>（例子）苏州街工作，我女朋友在通州工作，我们一周只能见一次面，都在北京，<br>感觉在异地一样，上家公司太远了，实在没办法，所以只能离职。</p><p><strong>有句老话：</strong><br><strong>自古深情留不住，唯有套路得人心 :)</strong></p><hr><p><strong>但是注意一点，这不是套路，这是个人风格的问题，你慢慢会发现，这些总结是无往不利的，没必要在这些问题上花太多时间</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《时间秩序》--颠覆对世界固有直觉</title>
      <link href="2020/11/29/The-Order-of-Time/"/>
      <url>2020/11/29/The-Order-of-Time/</url>
      
        <content type="html"><![CDATA[<h3 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h3><blockquote><p>还是那句话，有时候，入门和无知已经有很大的差距了，不是吗？</p></blockquote><p><strong>摘抄</strong></p><blockquote><blockquote><p>在物理学中，一个特定时钟测量的特定现象中的时间称为“固有时”（proper time）。</p></blockquote></blockquote><blockquote><blockquote><p>物体的位置是指其周围有什么。</p></blockquote></blockquote><blockquote><blockquote><p>只有当与其他相互作用的物体发生关联时，电子才会实体化。对于其他物体，相互作用的效应只会传播不确定性。只有与物理系统相关联时，实体化才会发生。我相信，这一点是量子力学做出的最激进的发现。</p></blockquote></blockquote><blockquote><blockquote><p>笼统地问“什么存在”或“什么是真实的”，只是在问你想要怎样使用这个动词和形容词。这是个语法问题，无关本质。</p></blockquote></blockquote><blockquote><blockquote><p>我们无法画出一幅世界上所有发生之事的完整地图或几何图，因为这些现象——包括时间的流逝——只有在与一个物理系统相互作用时才会出现。世界就像是相互关联的点的集合。谈论“从外面看到”的世界是没有意义的，因为没有什么在世界“外面”。</p></blockquote></blockquote><blockquote><blockquote><p>我们所感知的并不是当下，因为对在有限时间尺度上运作的系统而言这并没有什么意义。我们感知的是在时间中发生与延续的事物。在我们的大脑中，时间中的延续被压缩为对一段时间的感知。</p></blockquote></blockquote><p><strong>对本书的论点而言，有三个要素特别重要</strong></p><center><strong>1</strong></center><p style="text-indent:2em">第一个是，世界上每个人都有自己的一种视角。通过对我们生存必不可少的广泛关联，世界在每个人那里得到映现。[30]我们每个人都是复杂的过程，反映着世界，并以严格整合的方式，对我们接收到的信息进行加工和阐述。</p><center><strong>2</strong></center><p style="text-indent:2em">我们身份基础的第二个要素与战车的例子相同。在反映世界的过程中，我们把它组织为实体。我们会在一个大致均匀稳定的连续过程中，尽我们所能地通过聚合与分割来构想世界，与世界更好地相互作用。我们把一堆岩石组合成一个单独的实体，命名为勃朗峰（Mont Blanc），把它看作一个统一的事物。我们在世界上画线，把它划分为许多部分；我们建立边界，把世界分解为许多片，来估测它。我们神经系统的结构就是这样工作的，它接收感官刺激，不停加工信息，产生行为。形成灵活动力系统的神经元网络，会不断调整自己，力求对摄入的信息流做出尽可能长远的预测。为了完成这一点，神经元网络会把动力系统中大致稳定的固定点与所接收信息中反复出现的模式联结起来，或是在加工过程中间接做到这一点，以此不断进化。在当前非常活跃的对大脑的研究中，我们似乎已经看到了这一点。[33]如果真是如此，那么“事物”，像“概念”，就是神经动力中的固定点，由知觉输入与连续加工中反复出现的结构引发。它们反映了世界某些方面的结合，它取决于反复出现的结构及其与我们相互作用产生的关联。这就是一辆战车的组成。休谟会为我们对大脑理解的进展感到高兴。特别是，我们把组成其他人的生物体的过程集合整合为一个统一的形象，因为我们的生活是社会性的，因此我们与他人接触很多。他们是原因与结果的结点，与我们密切相关。在与其他同我们相似的人接触的过程中，我们形成了“人类”的观念。我相信，我们关于自我的概念就源于此，而不是通过内省。当我们把自己看作个人时，我相信，我们正把发展出来用来与伙伴交往的精神回路应用于自身。孩提时代，我关于自己的第一个形象就是我妈妈眼中的孩子。很大程度上，对自己而言，我们就是我们所看到的，以及朋友、亲人、敌人看到的我们。我从未相信过笛卡儿的观点，他认为经验的首要方面是对思考的觉知，因此我思故我在。（笛卡儿的观点在我看来甚至是错误的：在笛卡儿的重构中，我思故我在不是第一步，而是第二步；第一步是我怀疑故我在。）把自己看作主体并不是最基本的经验，而是个以其他众多思想为基础的复杂的文化推论。我最基本的经验——如果我们认为这确有意义的话——是看到我周围的世界，而不是我自己。我相信每个人都有“自己”的概念，这只不过是因为在某个特殊时刻，我们学会了向自己投射生而为人的概念，作为数千年进程中进化引导我们发展出的附加属性，以便与团体中的其他成员建立联系：我们从同类那里得到反馈，形成自我的观念，我们正是这些观念的映象。</p><center><strong>3</strong></center><p style="text-indent:2em">但是在身份的基础中，还有第三个要素，也许是最重要的一个：记忆。这就是这些细致的讨论会出现在一本关于时间的书中的原因。我们并不是连续时刻中的独立过程的集合。我们存在的每个时刻都通过记忆，由奇怪的三条线索与我们最近的和最久远的过去相连。我们的现在充斥着过去的痕迹。我们是自己的历史。我是我自己讲述的故事。我并不是此刻靠在沙发上在电脑上打下字母“a”的这副躯体，我是自己的念头，充满着我写下的语句的痕迹；我是母亲的爱抚，是父亲悉心教导出的宁静祥和；我是青春期的旅行；我是自己的阅读在脑海中的积淀；我是我自己的热爱，我的绝望时刻，我的友谊，我书写的，我倾听到的；铭记在我记忆中的脸庞。最重要的一点，我是那个一分钟以前为自己泡了杯茶的人，那个刚才在电脑里打下“记忆”这个词的人，那个刚刚写下正在完成的这句话的人。如果这一切全都消失，我还存在吗？我就是这部正在进行的长篇小说。我的生活由此构成。记忆把分散在时间中的过程联结在一起，而这些过程组成了我们。在这个意义上，我们存在于时间中。由于这个原因，今天的我与昨天的我是同一个人。理解我们自己也就是反思时间，而为了理解时间，我们也要反思自己。</p><blockquote><blockquote><p>奥古斯丁向自己发问，询问时间的本质，虽然有时会被一种令我备感无聊的福音传道士风格的感叹打断，但奥古斯丁清楚地分析了我们感知时间的能力。他说，我们一直在当下，因为过去已经过去，不复存在，而未来还未到来，因而也不存在。然后他问自己，我们如何能感知到一段时间，或甚至对它进行评估——如果我们只能处在当下的瞬间。如果我们一直在当下，又怎么能如此清楚地知晓过去、知道时间？此时此地，没有过去，没有未来。它们在哪儿？奥古斯丁得出结论，它们存在于我们的内心：<br>它在我头脑里，所以我才能测量时间。我千万不能让我的头脑坚信时间是什么客观的东西。当我测量时间的时候，我是在测量当下存在于头脑中的东西。要么这就是时间，要么我就对它一无所知。<br>初次读到这个想法似乎不觉得它令人信服，其实不然。我们可以说用时钟测量一段时间，但要这么做，需要在两个不同时刻读数。这是不可能的，因为我们一直在一个时刻，从未处于两个。在当下，我们只能看到现在；我们可以看到被理解为过去的痕迹的事物，但在看到过去的痕迹与感知时间的流动之间，有着明确的区别——奥古斯丁意识到，这种区别的根源在于，对时间流逝的感知是内在的，它是头脑不可或缺的一部分，是过去在大脑中留下的痕迹。</p></blockquote></blockquote><h3 id="★总结"><a href="#★总结" class="headerlink" title="★总结"></a>★总结</h3><blockquote><blockquote><blockquote><p>我们启程的时候，时间的形象还是我们熟悉的样子：在整个宇宙中均匀统一地流逝，一切都在这个过程中发生。在我们的观念中，整个宇宙都存在一个当下，一个“现在”，它构成了现实。对每个人来说，过去是固定的，已经过去，已经发生了。未来是开放的，还未确定。现实从过去流到现在，流向未来——在过去与未来之间，事物的演化本质上是不对称的。我们认为，世界的基本结构就是这样。</p></blockquote></blockquote></blockquote><p><strong>这幅熟悉的图景已经土崩瓦解，证明它只是一个更为复杂的现实的近似物。</strong></p><blockquote><blockquote><blockquote><p>整个宇宙中一个共同的当下并不存在（第3章）。事件并不按照过去、现在、未来的顺序排列；它们只是“部分”有序。在我们附近有个当下，但在遥远的星系中并没有什么“当下”。当下只是局部现象，并非整体现象。<br>掌管事件的基本方程中，过去与未来之间的分别并不存在（第2章）。这点源自这样一个事实：在过去，由于我们模糊地看待事物，世界所属的状态在我们看来很特殊。<br>在局部，根据我们的位置以及运动的速度，时间以不同速度流逝。我们离物体越近（第1章），或者运动得越快（第3章），时间延缓就越多。两个事件之间没有唯一的时间间隔，而是存在许多可能的时间间隔。<br>时间流动的节奏由引力场决定，这种真实实体有自己的动力学，由爱因斯坦的方程描述。如果忽略量子效应，时间与空间就是我们置身其中的巨大胶状物的某些方面（第4章）。<br>但世界是量子的，胶状时空也只是个近似物。在世界的基本结构中，既没有空间，也没有时间——只存在把一个物理量转化为另一个物理量的过程，由此，我们可以计算概率与关系（第5章）。<br>在目前已知的最基本层面，几乎没有什么与我们所经验的时间相似。不存在一个特殊的“时间”变量，过去与未来之间没有差别，不存在时空（第二部分）。我们仍然知道怎样写出描述世界的方程。在那些方程中，变量相对于彼此演化（第8章）。这个世界不是“静止的”，也不是一个一切变化都是假象的“块状宇宙”（第7章）。恰恰相反，我们的宇宙是事件的世界，而非物体的世界（第6章）。<br>这是此段旅程的去程，驶向一个没有时间的宇宙。<br>回程是一种尝试，试图搞清楚我们的时间感知是如何从这个没有时间的世界中出现的（第9章）。令人惊讶的地方在于，在时间令人熟悉的方面出现上，我们也扮演了重要角色。从我们的视角——构成这个世界一小部分的生物的视角，我们看到世界在时间中流动。我们与世界之间的相互作用是不完全的，因此我们用模糊的方式看待世界。量子不确定性也加重了这种模糊。来源于此的无知决定了一个特殊变量的存在——热力学时间（第9章），也确定了量化我们不确定性的熵的存在。<br>也许我们属于世界的一个特殊子集，与世界其他部分相互作用的方式导致了热力学时间在一个方向上熵比较低。因此时间的方向性是真实的，但与视角有关（第10章）：世界相对于我们的熵随热力学时间而增加。我们发现事物在这个变量里按顺序出现，我们称之为“时间”，熵的增加为我们把过去与未来区分开，导致了宇宙的演变。它决定了痕迹的存在，过去的残余与记忆的存在（第11章）。我们人类就是宏大熵增历史的结果，由这些痕迹产生的记忆聚集到一起。我们每个人都是统一的存在，因为我们反映着世界，因为通过与同类接触，我们形成了统一实体的形象，也因为它是一种由记忆统一的关于世界的视角（第12章）。我们所谓的时间“流动”就源于此，当我们听到时间流逝时，听到的就是这个。<br>“时间”变量是描述世界的变量之一，是引力场变量中的一个（第4章）。在我们的尺度上，无法记录量子涨落（第5章），因此我们可以认为时空是确定的，就像爱因斯坦的大型软体动物；在我们的尺度，软体动物的运动很微小，可以忽略，因此我们可以把时空看成像桌子一样的刚性存在。这个桌子具有维度，有我们称为空间的维度，也有我们称为时间的熵会增加的维度。在日常生活中，我们相对于光速以低速运动，因此感觉不到不同时钟的不同固有时之间的差别，离物体远近造成的时间流逝快慢的区别对我们而言太小了，也无法区分。</p></blockquote></blockquote></blockquote><p><font color="red"><strong>许多关于时间概念的讨论都很令人困惑，因为他们没有意识到时间复杂与多层次的一面。他们的错误之处在于，没有看到这些不同的层面是独立的。<br>这就是经过毕生思考之后，我所理解的时间的物理结构。</strong></font></p><p style="text-indent:2em">短暂的生命，不过是这样的：驱使着我们的不停呼喊的情绪。我们有时尝试以神或政治信仰的名义，或以一种仪式进行疏导，让我们安心：从根本上，一切都是有序的，都在伟大与无限的爱之中，并且这种呼喊很美妙，它有时是痛苦的呼喊，有时是一首歌。而这首歌，如奥古斯丁所言，是对时间的意识。它就是时间。吠陀圣歌[2]本身就是时间之花。在贝多芬的庄严弥撒乐曲中，小提琴的声音是纯粹的美，纯粹的绝望，纯粹的喜悦。我们停下来，屏住呼吸，神秘地感觉到这一定是意义的源头，这就是时间的来源。然后乐声逐渐消失。</p><p><strong>“银链折断，金罐破裂，瓶子在泉旁损坏，水轮在井口破烂；尘土仍归于地。”[4]这样很好。我们可以闭上双目，开始休息了。对我来说，这一切合理又美妙。这就是时间。</strong></p><p></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论入门</title>
      <link href="2020/11/28/Game-Theory/"/>
      <url>2020/11/28/Game-Theory/</url>
      
        <content type="html"><![CDATA[<h3 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%9A%E5%BC%88%E8%AE%BA">博弈论</a>该理论专门研究多个独立个体之间的竞争行为（对抗行为）。在某些中文书籍里面，它又被称作“对策论 or 赛局理论”。<br>本篇只做入门，后面有精力，会考虑详细学习，<br>有时候 入门和无知，已经能感受到巨大的差距了，不是吗？</p></blockquote><h3 id="★策略-＆-策略集合"><a href="#★策略-＆-策略集合" class="headerlink" title="★策略 ＆ 策略集合"></a>★策略 ＆ 策略集合</h3><p><strong>决策选项（move） VS 策略（strategy）</strong></p><p>　某些资料（比如维基百科）把“move”直译为“移动”。这个译法比较怪。在本文中，俺称之为“决策选项”。<br>　　很多人混淆了“策略”与“决策选项”。<br>　　以象棋为例，完成一局需要经历很多个步骤。对每个步骤，你都有 N 个决策选项（要走哪个棋子，走到哪）。而“策略”指的是——从第一步到最后一步的所有决策选项的【总和】。你可以把“策略”通俗理解为某种【算法 or 指导思想】，它指导你从第一步走到最后一步。</p><p><strong>★实例：（二战中）新几内亚的航路作战</strong><br>话说太平洋战场上，美日双方对新几内亚岛展开争夺战。美方通过截获的情报得知日方有一支补给船队要开往该岛。日军补给船队有两条路线可走（北线 or 南线），两条路线都耗时3天。在南线，这3天都是晴天；在北线有2天是晴天，1天是阴雨（阴雨天会影响美军轰炸）。<br>　　美方空军将领手头只有一个飞行队，需要决策：把这个飞行队派到哪一边执行轰炸任务？如果押宝的方向错误，重新部署又会浪费掉1天时间。<br>　　对这个博弈过程，美方的收益矩阵参见下述表格。表格中的数字表示“可用来轰炸的天数”（对美军而言，这个数字越大越好）。</p><table style>    <tr>        <td></td>        <td colspan="3" style="text-align:center">日方</td>    </tr>    <tr>        <td rowspan="3">美方</td>        <td></td>        <td>北线</td>        <td>南线</td>    </tr>    <tr>        <td>北线</td>        <td>2</td>        <td>2</td>    </tr>    <tr>        <td>南线</td>        <td>1</td>        <td>3</td>    </tr></table>　　从上述收益矩阵来看，美军应该选哪个策略，不那么明显。但如果【换位思考】，看日军的策略，就非常明显啦。<table style>    <tr>        <td></td>        <td colspan="3" style="text-align:center">日方</td>    </tr>    <tr>        <td rowspan="3">美方</td>        <td></td>        <td>北线</td>        <td>南线</td>    </tr>    <tr>        <td>北线</td>        <td>2,-2</td>        <td>2,-2</td>    </tr>    <tr>        <td>南线</td>        <td>1,-1</td>        <td>3,-3</td>    </tr></table>　第2个表格补充了日方的收益（以逗号分隔）。由于日方是遭受轰炸，其收益以“负数”表示。　　从日方的角度（表格的【纵向】角度）来看，走北线是其【支配策略】——不论美方如何选择，日方走北线的收益都不比南线差。对应到刚才介绍的概念，日方的这个“支配策略”属于“弱支配策略”。　　知道日军必定走北线之后，美军就很容易选定自己的策略了。<h3 id="★最小最大定理"><a href="#★最小最大定理" class="headerlink" title="★最小最大定理"></a>★最小最大定理</h3><p>这个玩意儿洋文叫做“Minimax”，比较绕口的陈述是：最小化最大损失。更通俗的表述是：在最坏情况下最小化损失。</p><p><a href="https://www.zhihu.com/question/20615717">分蛋糕博弈</a></p><h3 id="★反向归纳法"><a href="#★反向归纳法" class="headerlink" title="★反向归纳法"></a>★反向归纳法</h3><p>　该方法洋文称之为“backward induction”。其精髓是【正向展望，反向推理】<br>　首先，你需要思考自己的每个决策，以及对方在应对你的决策时，会采用何种决策（这个思维过程类似于【决策树的展开】）<br>　　这个展开过程要一直推演到【最后一步】（也就是决策树的叶子节点）。此时你就可以看清双方在最后一步各自的最优选择；然后再反向回推到第一步。</p><p><strong>海盗博弈（海盗分金问题）</strong><br>博弈场景描述<br>　　5个海盗抢了100个金币，讨论如何分赃。<br>　　这5个海盗有等级高低（不妨假设 A＞B＞C＞D＞E）。先由等级最高的海盗提出分赃方案，然后投票。如果半数以上（含半数）同意，就按这个方案分，游戏结束；如果同意的不到半数，把提出方案的海盗扔进海里喂鲨鱼，然后由次一等级的海盗提出新的方案；以此类推。<br>　　每个海盗的特点是：足够理性（追求个人利益最大化）并且知道别人也足够理性；足够残忍（在个人利益等同的情况下，倾向于把更多同伴扔进海里）。</p><blockquote><p>　　为了进行反向推理，假设最后只剩下2个海盗（D ＆ E）。此时的投票肯定过半（D 肯定投票赞同自己的方案）。在这种局面下，D 可以采用最极端的方案——自己全拿100个金币，E 则一个也拿不到。<br>　　现在回推一步。当只剩下3个海盗（C、D、E），由 C 提出方案。他只需要分1个金币给 E，E 就会投票支持（否则的话，等到由 D 来提方案，E 啥也拿不到）。所以在 C 的方案中，他自己拿99个金币，E 拿1个金币。<br>　　再往前一步。只剩下4个海盗（B、C、D、E），B 提方案，他当然也能想到刚才那些推理。他只需给 D 1个金币，D 就会支持他（如果等到 C 来提方案，D 啥也拿不到）。所以 B 提出的方案是 B：99，C：0，D：1，E：0，同样能得到半数支持。<br>　　基于上述分析，再看 A 的方案，就很显然了——A：98，B：0，C：1，D：0，E：1<br>    有些同学可能会觉得：A 还可以提出另一个等价方案 A：98，B：0，C：0，D：1，E：1（把 C ＆ D 交换）<br>　　其实这个方案【不】等价。如果是后面这个方案，D 会投反对票，于是 A 去喂鲨鱼，由 B 来提方案，D 还是可以拿到1个金币。虽然两种方案，D 都是拿1个金币。但基于规则中提到的【残忍性】，D 会对 A 的方案投反对票。</p></blockquote><h3 id="★纳什均衡"><a href="#★纳什均衡" class="headerlink" title="★纳什均衡"></a>★纳什均衡</h3><p>　所谓的“纳什均衡”，通俗地说是指——在多人的“非合作博弈”中，如果每个博弈者都无法【单方面】改善自己的境地，此时的局面称作“纳什均衡”。<br>　　冯·诺伊曼已经在《博弈论与经济行为》一书中证明了：零和博弈必定存在这样的均衡点。<br>　　纳什的贡献在于——他从“零和博弈”推广到“非零和博弈”，并证明了：这样的均衡点依然存在。<br><strong>实例：囚徒困境</strong><br><a href="https://zh.wikipedia.org/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83">囚犯困境</a></p><table style>    <tr>        <td></td>        <td colspan="3" style="text-align:center">囚犯B</td>    </tr>    <tr>        <td rowspan="3">囚犯A</td>        <td></td>        <td>坦白</td>        <td>抵赖</td>    </tr>    <tr>        <td>坦白</td>        <td>-2,-2</td>        <td>0,-5</td>    </tr>    <tr>        <td>抵赖</td>        <td>-5,0</td>        <td>1,-1</td>    </tr></table><p style="text-indent:2em">　　基于上述矩阵，“双方都坦白”的局面是“纳什均衡点”（表格中着色的格子）——在这个均衡局面下，任何一个囚犯【单方面】改变策略，只会让自己更不利。　　作为对比，“双方都抵赖”虽然是双赢的局面，但这个局面是【不】稳定滴。因为在这个局面下，任何一个囚犯都有动机去改变策略，从而让自己的获益更多。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《拖延心理學》讀後感及反思</title>
      <link href="2020/11/27/reflections_on_the_psychology_of_procrastination/"/>
      <url>2020/11/27/reflections_on_the_psychology_of_procrastination/</url>
      
        <content type="html"><![CDATA[<h3 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h3><blockquote><p>昨天自己生日，突然发现自己近几年没怎么去关注自己的年龄，仔细算了下，怎么我已经这个岁数了，开玩笑说，怎么像<br>一部恐怖片，时间都去哪了。<br>前两天大体做了个反思，这么多年过去了，是什么让自己平庸，甚至差劲，懒？浮躁？迷茫？有始无终？ 在《拖延心理学》<br>中，我似乎找到了答案，这本书从是什么？为什么？怎么办？系统的分析了我是怎么一步步走进深渊，又怎么一步步教我该如何<br>走出深渊的。因此读后留下点什么，告诫自己，或在往后的日子里再次出现迷茫、恐惧、逃避的时候，回来这里，给自己前行的方向。</p></blockquote><h3 id="★-拖延的表现-–-了解你自己"><a href="#★-拖延的表现-–-了解你自己" class="headerlink" title="★ 拖延的表现 – 了解你自己"></a>★ 拖延的表现 – 了解你自己</h3><blockquote><p><strong>拖延就像蒲公英。你把它拔掉，以为它不会再长出来了，但是实际上它的根埋藏得很深，很快又长出来了。</strong></p></blockquote><p><strong>拖延的4个根源</strong>：</p><ol><li><strong>情绪</strong><p style="text-indent:2em">拖延的情绪根源涉及内心感受、恐惧、希望、记忆、梦想、怀疑以及压力。虽然为了拖延而批判自己是相当痛苦的，但是相比费劲挣扎但仍然陷于恐惧之境的脆弱以及被暴露在众目睽睽之下的痛苦感受而言，自我批判的煎熬或许更容易被承受。</p></li></ol><p><strong>当你了解了自己的感受究竟是什么以及为什么自己会有这样的感受时，你就会有望变得更自信，更踏实，也更自在，这样你才能摆脱拖延，大步向前</strong>。</p><ol start="2"><li><p><strong>时间</strong></p><p style="text-indent:2em">拖延的另一个根源是拖延者与时间的纠葛。 如果你的主观时间跟钟表时间处于冲突之中，你就很难对最后期限有一个合理的预期，你也无法向着一个目标稳定地迈进，或者，对自己可以用多少时间将事情做完没有一个概念。</p></li><li><p><strong>生物</strong></p><p style="text-indent:2em">拖延的生物根源包括你的身体、大脑以及你的遗传基因。在你大脑中发生的事情会影响到你会回避什么样的感受，而你所回避的（或者你所没有回避的）会影响到你大脑的结构和功能。因为这种“神经可塑性”，大脑始终在变化，所以你的生物倾向性并不一定会对你的个人发展构成阻碍。</p></li></ol><ol start="4"><li><strong>人际关系</strong><p style="text-indent:2em">拖延的人际关系根源主要指你的家庭背景和社会关系，以及你在当今社会的地位。对自己在社会角色和文化角色上的忧虑或许也是构成你拖延习性的一个因素，要知道，它会影响到你的自我感觉以及人际关系。</p></li></ol><blockquote><p><strong>本书的一个主要观念就是：从你自己的经验中学习是一件令人兴奋而有趣的事情——不否认，不遗忘，不判断，而是如实接受，好好利用。</strong></p></blockquote><hr><p><strong>我怎么知道我是在拖延呢</strong></p><p style="text-indent:2em">人们经常不知道怎样辨识出真正的拖延，有时候我们只是将事情延后处理，因为我们没有时间去做每一件事，或者因为我们做事有所节制，需要一定的放松和休息，这两者的区别非常重要。</p> <p><strong>要弄清拖延有没有成为你的一个问题，有一个办法就是看它是不是让你烦恼不已。</strong> </p><p>为了理解你为什么会选择拖延作为你应对压力的基本策略，我们必须到你个人生活中寻找原因</p><p><strong>早期记忆</strong></p><p style="text-indent:2em">你还记得自己的第一次拖延吗？那是在一个什么样的环境下发生的？你是在学业上还是在父母叫你做的事情上拖拖拉拉？那时你多大？是在读小学还是中学……？甚至更早？后来结果怎样？你当时的感受又是什么？</p><p><strong>拖延者的信条</strong></p><p style="text-indent:2em">拖延除了作为一种自我保护的心理策略之外，它也是源于你对生活的一些顽固信念。</p><ul><li>我必须要做到完美。</li><li>我做每件事都应该轻而易举，不费力气。</li><li>什么也不做要比冒失败的风险更为安全。</li><li>没有什么是我无法做到的。</li><li>如果不能把事情做好，那么它就根本不值得去做。</li><li>我必须避开挑战。</li><li>如果我成功，有人就会受到伤害。</li><li>如果这一次我做得很好，那么我每次都应该做得很好。</li><li>按照别人的规定做事意味着屈服和失去掌控。</li><li>我不能承受失去任何人或任何事物。</li><li>如果我展现真实的自己，人们不会喜欢我的。</li><li>总有一个正确答案，我将一直等待直到发现它。</li></ul><p><strong>恐惧失败</strong></p><p style="text-indent:2em">很多拖延者担心被他人评判或者被自我评判，害怕自己的不足被发现，害怕付出最大的努力还是做得不够好，害怕达不到要求。他们的担忧反映了一种恐惧失败的心理。我们相信拖延可能是应付这种恐惧的一个心理策略。有些人宁愿承受拖延所带来的痛苦后果，也不愿意承受努力之后却没有如愿以偿所带来的羞辱。对他们来说，责备自己邋遢、懒惰和不协作比把自己看成无能和无价值（而这就是他们深为恐惧的“失败”）要容易忍受得多。而拖延就可以让这种恐惧有所缓和。</p><p>固有心态和成长心态</p><p style="text-indent:2em">固定心态认为：智力和才能是与生俱来的，是固定不变的。成功不过就是要证明你的能力，证明你是聪明的、有才干的。并且，在生活中面对每一个挑战的时候，你必须一再地证实这一点。</p><p style="text-indent:2em">成长心态认为：能力是可以发展的；通过努力工作，你可以随着时间推移而变得更聪明、更优秀。在成长心态看来，努力可以让你更聪明或者更擅长于某件事情；努力可以激发你的能力并成就自己。在这样的心态看来，你没有必要立刻擅长某件事情。事实上，做一些你不擅长的事情反而更为有趣，因为通过做这样的事情，你可以拓展你自己，并从中学习。</p><p><strong>这里提出值得深思的问题：“成功是为了学习和进步，还是为了证明你聪明？”</strong></p><p><strong>恐惧成功</strong></p><blockquote><blockquote><blockquote><p><strong>克来瑞·雷是拖延心理的一个研究员，她把成功定义为“及时追随目标”。从这个定义来看，不论什么时候，只要我们在做自己想做的事情，就会感到自己是成功的。</strong></p></blockquote></blockquote></blockquote><p style="text-indent:2em">对成功的渴望要比对成功的恐惧更容易鉴别出来，但是如果你在以下任何一个场景中找到你自己的身影的话，你就可能是一个恐惧成功的人。你会不会在一个进展顺利的工作中放慢脚步？当你得到很多认可和赞誉的时候会不会感到焦虑？当你的经理提出要提拔你的时候，你是不是开始希望自己成为一个隐形人？别人的称赞是否让你感到尴尬，或者让你感到担忧和谨慎？如果你在生活的某一个领域取得了成功，你是否会把另一个领域搞得一团糟？当事情一切进展良好的时候，你是否会认为坏事马上就要上门？如果你在自己的家族中比其他人有更多成功的机会，你是否担心失去跟你亲戚的良好关系？以上这些还只不过是恐惧成功的一部分经验。</p><p><strong>逃避成功的一般心理原因</strong></p><ul><li>成功需要太多付出：这令我望而却步<ul><li>害怕被人看出自己的软弱和无能</li><li>外在过分的期待</li><li>进步的危险</li></ul></li><li>成功是危险的：总有人会受到伤害<ul><li>我会受到伤害</li><li>我不能伤害别人</li></ul></li><li>成功是禁区：我觉得自己不对劲<ul><li>我命中注定不能获得成功</li><li>幸存者歉疚</li></ul></li></ul><p style="text-indent:2em">当你停滞不前的时候，回想一下,恐惧怎样横亘在你前进的道路上？你是否因为害怕即将到来的失败或者成功而停下了你的脚步？你是否对那些发号施令的人决不屈服？你是否对跟人太接近或者跟人太疏远而感到惴惴不安？你是否扮演了一个符合家庭期待的角色，或者，一个符合你朋友期待或者符合学校期待的角色？</p><h3 id="★-为什么会拖延-–-你在想什么"><a href="#★-为什么会拖延-–-你在想什么" class="headerlink" title="★ 为什么会拖延 – 你在想什么"></a>★ 为什么会拖延 – 你在想什么</h3><p><strong>争夺控制权的较量</strong></p><p>你以自己的独立为骄傲，不做任何妥协，因为你想证明没有人可以强迫你违反自己的意愿。拖延类似于这样一个宣言：“不！你不能强迫我就范！”那个发信息给你的人非常鲁莽，他以为你会乖乖地在他约定的时间内给他回电，但是你偏不。公用事业公司或许势力很大，但是他们无法迫使你准时付费。你会在自己感觉良好的时候去做家务，而不是在你妻子叫你去做的时候。拖延成了这场争夺战的一个策略——它成了争夺控制权以及赢得尊敬和独立自主的一场争夺战。</p><p><strong>个体独立性的问题</strong></p><center>自我价值感=能力（具有独立性，反对受控制）=表现（通过拖延，“我”说了算）</center><p>拖延常常是一个人的独立宣言，一个人试图通过拖延来告诉人们：“我是一个拥有自主权的人。我根据自己的选择来行动。我没有必要按照你的规定或者要求来做事。”利用拖延来抵制被人控制的人可能是想保有他们独立的个体感，他们必须确信他们是按照自己的方式在生活。</p><ul><li>秘密的战斗</li></ul><p>对害怕在争战中败下阵来的拖延者而言，把自己所想所感暴露给别人看会让他们感到自己极为脆弱。他们关注的不是一旦暴露就有人来评判他，而是他们的权力会被解除，他们的弱点会被追究。在秘密中战斗似乎要安全多了。</p><ul><li>防卫的哲学<ul><li>世界不可预知</li><li>他若强势，我必软弱</li><li>合作相当于投降</li></ul></li></ul><p>不论拖延是被用来对付小的冲突，还是被用来跟别人作全面对抗，这些人只关心战斗胜败，他们似乎对这个世界以及他们影响这个世界的能力有几个基本的假设。</p><ul><li>争战的根源</li></ul><p>你或许会通过回忆你的成长经历而帮助自己了解到：你怎么会一开始就把这个世界看成是一个战场，你怎么会把人们都看成是具有潜在控制欲的对手。很多对被控制比较敏感的拖延者都是成长在一个不鼓励自主把握生活的环境中。这些孩子可能从小被严格地管束，个人习惯被过度干预，他人强烈的好奇心让他们感到受到侵犯，不断的批评让他们失去自信，太多的限制压制了他们的自发性和创造性——所有这些都阻碍了他们通向独立的道路。</p><p><strong>恐惧疏远：我决不独自行走</strong></p><p>当一个人感到他们无法完全依靠自己做事的时候，就会在需要独立运作的事情上退缩彷徨。<strong>当人们对自己的独立自主性持犹疑态度的时候，他们会采取哪些方式来运用拖延策略呢？</strong></p><ul><li>需要帮助</li><li>害怕没有伙伴会让他遍的慵懒无助</li><li>主动陷入可伶和绝望的境地，期望有人来拯救他们</li></ul><p><strong>恐惧亲近:关系太近让人不舒服</strong></p><p>害怕疏远的人都是通过与人保持亲近的关系来获得巨大安全感的。而害怕亲近的人则刚好相反，与人保持距离会让他们更加自在。一旦有人可能会逼近他们，挤压他们，拉扯他们，有求于他们，他们马上就提高了警惕。他们依赖于自己的雷达系统，不断地扫描周遭的环境，寻找是否有被侵犯的迹象。一旦有人在雷达屏幕的边缘出现，他们就会变得焦虑不安，并马上采取撤退的行动。拖延是他们逃跑的一种方法。</p><p><strong>你理解的时间对拖延的影响</strong></p><ul><li>客观时间和主观时间<p style="text-indent:2em">古希腊人认为时间有两个方面——钟表时间和沉浸时间，钟表时间之外的时间才有意义和价值。现代人对时间有一个相同的区分。“**客观时间**”日历来衡量的，它是不可更改的，可预知的：我们都知道每年都会有4月15日；电影在7点15分开场，如果你没到那里，你就错过了开头。相反，我们对时间的流逝都有自己独特的感觉，而这是不可量化的，也无从比较，这就是“**主观时间**”对于钟表之外的时间的经验。有时候我们感到时间过得很快；还有一些时候，时间又慢得像蜗牛爬。当你在做自己喜欢的事情时，无论是在互联网上冲浪还是在装饰你的爱车，或者赖床不起，时间都过得令人无法置信的快。</p></li></ul><p style="text-indent:2em">很多拖延者生活在主观时间和客观时间的严重冲突中，不愿意也不能认知到它们的时间概念与钟表时间有着很大的差异。与那些能够在主观时间和客观时间之间自由而流畅地出入的人不同，他们一直在其间挣扎。有些人把钟表时间看成无关紧要的，认为它不够人性。有些人则始终处于时间混乱中，一开始似乎一切进展顺利，但是因为突然之间发现时间不够而晕头转向，而这样的经历只会在他们身上一再重演。</p><p style="text-indent:2em">社会学家津巴多对时间感知进行了全面的研究，结果显示：人们是参照基于过去、现在和未来的不同坐标来感知时间的。如果你只是局限于其中某一个时间坐标，那么你的生命观就会发生偏差和受到局限。那些可以在三种不同的时间坐标参照中保持平衡的人最有可能适应社会发展的步伐，也更能够充分地享受生活。</p><p><strong>时间感的演化</strong></p><ul><li><p>婴儿时间</p><p style="text-indent:2em">时间完全是主观的。不管时钟上的时间是几点，“我现在饿了”。</p></li><li><p>幼儿时间</p><p style="text-indent:2em">孩子们逐渐学会了什么是过去、现在和将来。虽然他们现在非常饥饿，但是他们会在几分钟内就有好东西吃了。虽然学步阶段的孩子基本上还是生活在主观时间中，但是他们也开始逐渐适应父母亲的时间。父母可能会要求孩子马上配合——“现在就停止玩玩具，马上到这里来！”或者通过“玩耍时间结束了”这样的一些提醒。</p></li><li><p>儿童时间</p><p style="text-indent:2em">大约7岁的时候，孩子开始知道怎么叙述时间，他们认得出时钟上各数字之间的关系表示的是一段时间的间隔。</p></li><li><p>少年时间</p><p style="text-indent:2em">青春期的开始标志着一个人时间感的戏剧性转变。他们看到了时间流逝的铁证，一个长大了的十几岁少年跟一个儿童的身体有着显著的不同，并且是不可逆转的。</p></li><li><p>青年时间</p><p style="text-indent:2em">在你二十几岁的中后期，虽然时间继续长长地延伸到未来，感觉上非常充裕，但是它现在已经变得更具有现实感了。他们会认识到他们可能没有足够的时间去完成每一件事情，有些机会可能会错过，在这个阶段，为了检验他们跟时间的关系，可以看一看**拖延**在他们生活中扮演的角色。</p></li><li><p>中年时间</p><p style="text-indent:2em">30岁是一个重大的分水岭。过了30，你不再是一个怀着许多未来梦想的年轻人了；你被期待着在自己的潜能上有所表现！在30以后的中年人生中，当你在事业或感情中表现拖沓的时候，这或许表示你的事业或感情出现了问题。拖延者难以接受人生的限制，当他们发现他们一直以为会在某一天实现的目标在人到中年时依然没有实现的时候，他们震惊了。</p></li><li><p>老年时间</p><p style="text-indent:2em">对于一个跟生命的有限性做着抗争的拖延者而言，接受生命无可避免的终结是一项具有重要心理意义的挑战。在这个时刻，他不再否认自己一生拖延所产生的种种后果。你一直没有存起来的钱现在依然账户空空，想重新改造的房子从来也没有被改造过。不再有研究生课程。</p></li></ul><p><strong>陷在另一个时间区域</strong></p><p style="text-indent:2em">带着他们跟时间的独特关系，拖延者对于时间的感知往往与他们所处的人生阶段不相符合。例如，许多成人拖延者对于时间的认知仍然停留在青少年时期，而青少年对于时间的流逝是毫不在意的。当你的时间阶段跟你的人生阶段不能吻合的时候，你的拖延会将自己拖到一个大麻烦中。</p><ul><li><p>时间迷失</p><p style="text-indent:2em">不受时间限制（timelessness）的主观感觉所产生的后果既是积极的又是消极的。时间迷失成了你的生活方式，那就可能会产生严重的后果。无法分清有限和无限，会让你在根本上失去方向感。</p></li><li><p>时间断裂</p><p style="text-indent:2em">对一个崭新的你的期待或许是诱人的，但是也可能是有问题的。在没有接受过去的你与现在以及未来的你之间的情况下，你丧失了自我的连续感。为了改变这样的状况，你首先得接受组成你生活的那些经验。接着，你得接受负责做出改变的正是原来的那个你。奇怪的是，当你接受了原来的那个你，从自己真正所站的位置开始做起，你就更有可能成就一个崭新的自己。</p></li><li><p>过去的好时光</p><p style="text-indent:2em">拖延使你提前避免了面对这样一些与时间相关的事实：时间在不断流逝；未来正在到来；你正在变老；</p></li></ul><h3 id="★-应对拖延前的准备-–-科学认识自己"><a href="#★-应对拖延前的准备-–-科学认识自己" class="headerlink" title="★ 应对拖延前的准备 – 科学认识自己"></a>★ 应对拖延前的准备 – 科学认识自己</h3><blockquote><blockquote><blockquote><p><strong>先来总结一下神经科学最新发展的几个“大观念”，以便于大家更好地理解我们的大脑是如何工作的。在对我们人体最复杂部位的大脑的细致了解中，我们每个人都可能会受益匪浅，你也可以运用这些知识来帮助自己克服拖延症。</strong></p></blockquote></blockquote></blockquote><p><strong>你的大脑处在不断的变化中</strong></p><p style="text-indent:2em">大脑始终在变，说它是个好消息，是因为它能激发人新的灵活的行为；说它是个坏消息，是因为它也能强化旧的顽固的行为，这被称为“可塑性悖论”。</p><font color="red"><strong>这本书就是要帮助你增强你的意识觉察力，让你觉察到拖沓的时候你在做什么以及你为什么要这样做，这样你才能帮助自己从惯性的“凹槽”中跳脱出来，以新的方式看待你的拖延，并运用我们建议的实践技巧，你一定能打破旧的拖沓模式，发展出一个及时完成任务的做事新模式。</strong></font><p><strong>感受很重要，即便它处于无意识中</strong></p><p style="text-indent:2em">感受是意识的一个重要组成部分。你的感受对你本人意义重大，你可以运用你的感受来引导自己，你也可以通过倾听自己的感受来做决定。研究人员了解到，本能反应和直觉是智慧的一个反映。如果你大脑的某个部分（额叶）受到损害，你就失去了运用情感来做出聪明选择的能力。如果你跟自己的感受失去了有效联系，你就无法利用这个自我认知的源泉来帮助你穿越人生的种种障碍。</p><p style="text-indent:2em">大脑感知这种触感大约需要400～500毫秒的时间。但是感知恐惧只需要14毫秒！在你有机会感知到恐惧之前，你的身体早已探测到它并开始做出反应。在你想到去做那个你一直在逃避的事情的时候（比如打一个让你恐慌的电话或者计算你去年的年收入），你的身体马上对这样的恐惧做出了躲避反应，所以也难怪你会推迟。除此之外，你的身体还留存了这个恐惧。一旦大脑在一个刺激（比如，一条蛇，一篇期末论文，一次面对上级主管的演讲）与一种危险或恐惧的感受之间建立了一种联系，这种联系就无法被消除。</p><p>为了对付恐惧和冲动，人类逐渐发展出了一系列的<strong>防卫机制</strong><br>，将不堪忍受的痛苦的思想、情感及记忆阻挡在意识范围之外，因为在理解微积分的复杂概念时，你会感到自己很愚蠢，也因而十分厌恶自己，<strong>你的防卫机制很可能就是用来防止自己受到这种痛苦情绪的侵袭的</strong>。</p><p><strong>潜伏记忆的影响</strong></p><p><strong>潜伏记忆</strong>有时候也被称作“早期”记忆，因为它们通常在3岁之前就埋藏在你的大脑中，那个时候负责记忆储存的大脑海马体还没有得到较为充分的发展。在你的余生，它们经常会从无意识中被激活。</p><p><strong>联结的通路</strong></p><p>当你在某件让你感到无法处置或者不舒服的事情上拖延时，你同时还卷入了一场怎样看待自己的挣扎：你是有能力的吗？你可以有自己的想法吗？你值得被爱、值得被尊敬吗？<strong>低自尊也是拖延症的一大原因</strong>。</p><p><strong>左逆转</strong></p><p>证据说明大脑左半球的某一个部分（左额叶）是跟关照、感应和同情这样的感情有关的，在一种不舒服的、负面的情绪中，我们就会倾向于撤退到自己的世界中。主管这些负面情绪的部位是在大脑的右半球。友善地对待自己会刺激大脑的相应部位（所谓“<strong>左逆转</strong>”）。</p><p><strong>迷走神经</strong>对你的情绪调整和社会交往发挥着极为关键的作用，它也跟你体内的后叶催产素（脑下垂体后叶荷尔蒙的一种）分泌增加有关。</p><p><strong>后叶催产素</strong>有助于调整社会关系和对其他人的情感依赖。一些研究指出，触摸可以增加后叶催产素分泌（按摩是好东西），某些食物，比如巧克力（巧克力是一个非常好的东西），也可以增加后叶催产素分泌。</p><p><strong>那么，后叶催产素、迷走神经、同情和友善……这些东西跟拖延症有什么关系？</strong><br>你着手做一件难事，你的大脑依然会显示出恐惧的迹象，一个友善的声音会给你足够的安全感去走进这个不舒服的情感地带。当你的思想富有同情心，你的身体会反应良好，你整个的自我也会以更加完整而协调的方式进入良性的运转，那么你成为拖延的囚犯的可能性也就越小。</p><hr><p>上面介绍了我们的大脑是如何工作的，给我们在摆脱拖延有了理论上的铺垫，那么我们<strong>如何打造大脑的领导力</strong>，我们大脑在生物性基础上和拖延症息息相关呢</p><p><strong>执行功能障碍</strong><br>执行功能具体包含哪些能力</p><blockquote><p>1.启动任务（起始，产生行动的想法）。<br>2.维持注意力（持续跟进，专注于一个事项）。<br>3.抑制冲动（在行动前有所思考，而不是马上反应）。<br>4.转换注意力（从一个事项到另一个事项，转变关注的焦点，有弹性地加以回应）。<br>5.流程记忆（记得计划、指令和以前学到的知识，在学习新知识和应对新环境的时候可以记起和运用到旧的知识）。<br>6.情绪控制（调整和管理情绪）。<br>7.组织材料（获取所需的材料，并依序编排）。<br>8.自我监测（具备自我评价的相应语言能力，在必要的时候能够通过自我交谈闯过难关）。<br>9.时间管理（时间意识，以及对待时间的务实态度）。<br>10.计划（按优先次序考虑问题，找出达成目标的各个步骤，提前为以后的需要和相关进程做好准备）。</p></blockquote><p style="text-indent:2em">当你通读这个列表，对其中一些项目是否有一些似曾相识的感觉？你是否因为找不到自己所需要的东西而经常迟到？你是否心急火燎地想要找到它们？你是否赶不上时间进度？你是否遗忘了自己计划所要做的事情，哪怕就在五分钟之前你才做这个决定？当有人问你“你在想什么”的时候，你是否有点不知所措？</p><p><strong>注意力缺失紊乱</strong></p><p style="text-indent:2em">当我们说某个人注意力分散、冲动或者躁动不安的时候，它代表的究竟是什么意思呢？ ADD的根本问题在于一个人没有抑制能力。也就是说，一个ADD患者不能运用时间上的自我控制来抑制他对当下时刻的反应，一般人会这样想：“我想在历史课上取得优异成绩，所以我必须完成这份作业，以便明天及时交上去。”而一个ADD学生是这样想的：“这很无聊！我不想做作业！”然后他就去找一些更有趣的事情来做，这就是拖延。</p><p><strong>倾向与变种</strong></p><p><strong>焦虑症</strong></p><ul><li>强迫症</li><li>邋遢分子和囤积狂<br>优柔寡断+对犯错误的恐惧=邋遢分子</li></ul><p><strong>压力对人的影响</strong></p><p><strong>生物节奏</strong></p><p><strong>睡眠：睡眠债和睡眠窒息</strong></p><p><strong>一点提示</strong></p><p style="text-indent:2em"><font color="red"><strong>无论你怎样挣扎，在你所经历的拖延症背后总有着某些生物性因素在其中起作用。在你延后的某个时刻，可能你的大脑侦测到了危险，拖延是你的本能反应和自我保护。很可能你的大脑遇到了麻烦，比如执行功能紊乱或者注意力缺失紊乱，所以才引起了你一直拖三拉四的问题。</strong></font></p><hr><hr><hr><hr><p>现在我们来总结一下，<strong>你是怎么变成一个拖延者的</strong></p><blockquote><p>1.注意力缺失多动紊乱症（ADHD）、多动症<br>2.文化差异带来的压力<br>5.榜样对拖延的影响：永远不可能像他们一样成功<br>6.家庭态度：拖延的成因<br>7.家庭倾向：施压倾向、怀疑倾向、控制倾向、依附倾向、疏远倾向<br>8.家庭对自尊的影响<br>9.被遗忘的早年经历<br>10.一切都与爱有关<br>以上的因素，很容易导致 缺乏自信、回避掉一些困难的选择和可能的内心失落，而拖延看起来是让内心趋向舒适的不错的决策</p></blockquote><p style="text-indent:2em">你对不好的信息是怎样反应的？尝试看看你是否能够以积极的、良性的话语来跟自己进行内心的对话？例如，当那个“如果一件事情不能做好，那么它就不值得做”的声音出现时，你可以这样应对：“这是不对的，做总比不做好。”或者，当你的内心出现这样的声音：“小心！你还没有准备好！”你可以这样为自己鼓劲：“虽然我不太了解自己所做的事情，但是没关系，至少我可以尝试一下。”像这样鼓励自己的内心对话对你的身心都有好处。当你的关注点有意识地从负面情绪转移到正面情绪，你就是在打破固有的大脑运行模式，而在你的大脑中创造出一个新的运行模式。下面的方法强烈建议有拖延症的患者学习掌握。</p><p>重要的心理措施：<strong>内心的检察官与辩护律师</strong></p><p style="text-indent:2em">为了反击内心检察官的指责，拖延者可以在内心培养另一个声音，一个辩护律师的声音，当那个检察官冒出来的时候，这个声音就可以代表你对它加以还击。这个辩护律师的内心声音可以创造全新的积极思想，它可以帮助我们建立新的神经连接，弱化老的连接。自我辩护的练习做得越多，它在大脑中的运转就会越发自动，对维护大脑平衡起到的作用就越大，你也就会越来越自信。</p><blockquote><p>例子：<br>检察官：你这个愚蠢的白痴！你又把事情搞砸了。想要在这家公司工作，你还不够聪明，迟早他们会发现原来你是个笨蛋。<br>辩护律师：早一点开始做的话，我会做得更好。<br>检：你应该很清楚必须早点开始，而不是一直坐等这么久。<br>辩：我还有很多其他事情要处理。<br>检：你总是找借口。不是这件事情，就是那件事情，没完没了。<br>辩：请你消停消停，这样我就可以更轻松地回到工作中。<br>检：我为你好才对你严格要求，没有我，你就没有动力了。<br>辩：这不是事实。如果你没有不断地攻击我，我可以做得更多更好。<br>检：但是那样你就一文不值了。<br>辩：不要为我预测未来。我已经学到很多东西，每一个经验都会让我变得更好，我只能脚踏实地，从眼前做起。</p></blockquote><h3 id="★-如何摆脱拖延-–-作战计划"><a href="#★-如何摆脱拖延-–-作战计划" class="headerlink" title="★ 如何摆脱拖延 – 作战计划"></a>★ 如何摆脱拖延 – 作战计划</h3><p><strong>改变是一个过程:认识改变的历程</strong></p><p>詹姆斯·普罗察斯卡（James Pmchaska）和他的同事研究了健康习惯和药物滥用方面的改变过程，他们找到了一个可以预知的改变顺序，他们称之为“改变的阶段”</p><ul><li>第一个阶段是“前关注”<br>在这个阶段你没有准备要做改变，甚至都没有想过要做改变</li><li>第二个阶段是“有意识无行动或醒悟”<br>如果我们不做那些应该做的事情，我们将会付出多么大的代价</li><li>第三个阶段是“有意识有行动或者决心改变”<br>致力于去完成那些被意识到应该去做的事情。这可能是改变过程中比较令人尴尬的一个阶段，因为学习新的行为方式需要付出努力，也需要不断实践和重复，在这个过程中我们会碰到很多挫折</li><li>第四个阶段是“无意识有行动”（unconscious competence）阶段<br>认为应该做的事情已经成为一个习惯，我们不用费劲甚至不假思索就可以做到。</li></ul><p><strong>找出导致拖延的因素：定位自己的问题</strong><br>这里列出四个主要因素，帮助你找出产生拖延行为真凶:</p><ol><li><p>对成功所需的能力缺乏自信。</p></li><li><p>对要去完成某个任务有反感心理：认定做事的过程中会遭遇很多困难，结局也会很惨。</p></li><li><p>目标和回报太遥远了，感受不到对我有什么意义。</p></li><li><p>无法自我约束，例如容易冲动和分心。</p></li></ol><p>这里有几个使用技巧，这里需要提前打个预防针和一些注意事项：</p><ol><li>一次尝试一个技巧</li><li>慢慢来</li><li>观察内心的抵抗<br>建议你要同时留意一下自己内心有没有抵抗情绪。例如，虽然你在处理拖延问题上开始有所进步，但是你可能还是会因为自己努力不够、进步不大或者没有完成自己设定的所有目标而对自己感到失望或者生气。或者，你也可能会觉得我们对你要求太多了。不管抵抗情绪采取什么样的形式表现出来，它会让你停留在原地停滞不前。</li><li>使用笔记或者日记：追踪你变化过程的一个好办法就是记日记。</li><li>自由书写<br>在一个有限的时间内将你的所思所想以一种不停顿、不判断和不做修饰的方式书写下来。这种方式通常被书写者用于激发自己开始做事的动力，或者发现某些没有被自己意识到的想法，在二十分钟左右的自由书写过程中，你所要做的就是一直写下去，哪怕你写的是“我没有什么好说的”或者“我不知道接下来该写些什么”。不要把你的笔从纸上挪开（或者，不要停止敲击键盘），只要将你的思绪写下来就可以了。不必担心标点、拼写和语法，也不必担心你写的是否有意义，或者是否准确。不要涂抹，不要划掉，也不要删除。自由书写的目的不是要写出一篇美文，而是要在不做判断的情况下去了解你的思维和情绪。</li><li>考虑心理治疗</li></ol><p><strong>记住</strong>，重复是非常重要的，在改变你的大脑的过程中，每一步都很重要。因此，坚持住，别放弃！</p><p><strong>拖延大盘点</strong></p><p>控制拖延的一个关键步骤就是对你的个人拖延方式进行清查。如果你以一个旁观者的身份来观察自己，你就会对自己的拖延问题有更多的了解：不需要评判，只需要去清点，好让自己更为清楚地觉察到 <strong>自己的拖延心理和言行。</strong></p><ul><li><p>盘点你的内心挣扎</p></li><li><p>拖延导致的外在的与内在的后果</p></li><li><p>拖延的领域</p></li><li><p>你的拖延风格</p><p style="text-indent:2em">你在拖延的时候会做什么？尽量多地观察你的种种表现，从最典型的行为模式，到最不显眼的拖延策略，你都要加以注意。有很多时候，某种行为是否属于拖延是很难区分的。例如，什么时候算是放松大脑和休养生息，什么时候又算是逃避呢？什么时候家居清洁属于必须完成的事情而不属于拖延呢？阅读报纸属于拖延还是放松呢？如果你是一个因为拖延而经常对自己生气的人，那么学会区分什么是消磨时间什么又是放松身心就很重要。即便是拖延的人也拥有享受生活的权利。</p></li><li><p>拖延的借口</p><p style="text-indent:2em">想一想有没有什么时候你本来可以开始做一件事情而你又把它推迟了呢？在那样一个时刻，你本来可以打个电话，写下第一句话，或者打开第一个箱子。这个时候你又对自己说了什么话，让自己对不去做这件事情感到心安理得</p><p>  借口清单：<br>  1.我得先准备充分才行；现在还有一些事情没有到位。<br>  2.现在我根本没有时间做完它，所以做了也没有什么意义。<br>  3.多好的一天啊，把时间花在这件事上太委屈自己了。<br>  4.我已经干得很努力了，休息一下是应该的。<br>  5.如果等待好的时机，我可以做得异常出色。<br>  6.等我有了热情再说吧。<br>  7.我感觉不太好；我现在太累了；我不在状态。<br>  8.做这事用不了多少时间，我还有大把时间呢。<br>  9.我正乐在其中呢，再给我一点时间玩玩。<br>  10.我得先做锻炼（睡觉、吃东西等）。<br>  11.跟上这个世界的步伐很重要，所以我最好先看看报纸。<br>  12.这周开始做的话，已经太晚了。<br>  13.干吗要在周五发送这个东西呢？反正下周一之前没人会看它。<br>  14.周末我会有更加充足的时间。<br>  15.干吗要去问呢？反正他们的回答是不。<br>  16.我已经完成了最难的部分，最后一步不过是小菜一碟。<br>  以一周为周期记录你所采用的借口，留意那些在你将事情推迟的当口所出现的念头，正是这些念头给了你一个等待的理由。对心里的想法保持清醒的认识，观察自己的想法怎样影响了行为，这些做法对你都大有好处。<br>  就在你为自己的拖延找到一个理由之前，看看你能否发现究竟发生了什么事才会刺激你的拖延动机。在找到拖延理由之前，你在想什么？你有什么样的感受？或者，你在做什么？周围的环境又是怎样的？是什么触动了你？</p></li></ul><p style="text-indent:2em">如果你对什么是拖延、自己的拖延的表现、在计划改变现状的时候，大脑扮演的角色，一些摆脱拖延过程中需要注意的点和技巧，那么就来一起开始和拖延大作战吧</p><p><strong>作战武器：明确的目标与可行性的计划</strong></p><ul><li><p>可操作目标<br>可操作性的目标具有以下特征：</p><ul><li>◎可观察性；</li><li>◎具体性和特殊性；</li><li>◎它可以被分解成几个小的步骤；</li><li>◎第一步可以在五分钟内被完成。</li></ul></li><li><p>一周试验</p><ul><li><p>选定一个目标：列出步骤。将你的可操作目标分解为几个组成部分。每一个部分就是一个步骤，一个小目标。</p><p>（例子）目标：<strong>周六、周日各花两个小时（共四个小时）将我的家庭办公间做一次整理和清洁</strong>。<br>步骤：<br>  A.整理文件和打印物</p><blockquote><p>1）清理桌面和地板上的堆物，将无关紧要的东西都扔掉。<br>2）将衣服和鞋子放进壁橱，杯子放进厨房，书本放进书柜，杂志放到回收箱。<br>3）将所有的账单放进一个盒子。（我有这样的一个盒子吗？）<br>4）将收据放进另一个盒子。（盒子够不够用？）<br>5）购买文件夹。<br>6）整理小物件、照片和剪报。<br>7）将需要保存的文件归档，将其余文件扔掉。</p></blockquote><p> B.打扫办公间</p><blockquote><p>1）清洗电脑屏幕和键盘。<br>2）打扫文件和书柜灰尘。<br>3）清空废纸篓。<br>4）房间吸尘。</p></blockquote></li><li><p>可行性检查：所有这些事情能否在四个小时内完成？<br>这第一步应该是一件非常细小和简单的事情，类似找到去年的退税单，购买一本笔记本，或者找几个空盒子。</p></li><li><p>启动</p><ul><li>观想你的进步</li><li>坚守时间期限（刚开始感到吃力，每个步骤可以尽可能的短，那个是设定1分钟）</li><li>不要等到自己有意愿和感觉的时候才开始</li></ul></li><li><p>跟进<br>以下一些原则可以指导你如何跟进而不轻言放弃</p><ul><li>小心自己的借口</li><li>在一段时间内只专注于一个步骤</li><li>解决困难<br>如果你将这个障碍看成是一个需要你去解决的难题，或者把它看成需要加倍努力才能完成的一件事情，那样它就成了这项任务本身属性的一个反应——而并不说明你是怎样一个人。一个障碍就是一个障碍：它不是对你愚蠢、无能或无用的一项控诉。</li><li>休息<br>半途停了下来，在休息之前，你可以记下一句话，或者一些想法或短语。那样的话，当你回来的时候，你就可以有一个下手的地方</li><li>适当的奖励</li><li>灵活对待目标（在某些情况下，你可能有必要改变你的目标，如生病、事故、朋友来访）</li><li><strong>无需完美</strong></li></ul></li><li><p>回顾<br>一周试验结束的时候，回顾一下其间发生了哪些事情。认真的回顾是自我监测的一种重要形式——否则你怎么能从自己的经验中学习呢？</p><ul><li>估你的进步（也包括不足）</li><li>回想你的选择关口<br>有些时候我们在经受放弃的诱惑，或者在选择的两边摇摆不定，不知道要走下去，还是要避开。还有一些时候我们既可以往前迈进，也可以放弃，这些选择的关口是非常重要的时刻。在这样的时刻做出的选择不仅对我们的表现有影响，也对我们的自我感觉有影响。</li></ul></li></ul></li></ul><p><strong>作战方法A：学会怎样判断时间</strong></p><ul><li>非计划的事情</li><li>提升你定时能力的技巧</li></ul><p><strong>作战方法B：学会“接受”和“拒绝”</strong></p><ul><li>学会接受有益于你的人和事</li><li>学会拒绝那些没有意义的追求</li><li>对杂乱无序说不</li></ul><p><strong>作战方法C：利用你的身体减轻拖延</strong></p><ul><li>通过运动启动你的状态</li><li>正念：主题及其变奏<br>指的是“在当下时刻对周遭环境不带判断地保持有意识的觉察”。</li></ul><p><strong>最后的一些建议</strong></p><ul><li>执行提示点<br>你设立了一个很有意义又很现实的可操作目标，你的目标也很清晰，你也很想去实现它，但是你的工作记忆能力表现不是很好，当你在五分钟之后想要跨出你的第一步时，你完全忘记了自己想要做的是什么事情！</li><li>架构和线路的重要性</li><li>保持短小<br>建议，就是每次花15分钟的时间往前迈进一步</li></ul><h3 id="★-拖延处理技巧汇编"><a href="#★-拖延处理技巧汇编" class="headerlink" title="★ 拖延处理技巧汇编"></a>★ 拖延处理技巧汇编</h3><blockquote><p>1.确立一个可操作的目标（可观察、具体而实在的），而不是那种模糊而抽象的目标。<br>不是：“我要停止拖延。”<br>而是：“我要在九月一日之前打扫和整理我的车库。”<br>2.设定一个务实的目标。不要异想天开，而要从小事做起。不要过于理想化，而要选择一个能接受的程度最低的目标。<br>不是：“我绝不再拖延！”<br>而是：“我会每天花一个小时时间学习数学。”<br>3.将你的目标分解成短小具体的迷你目标。每一个迷你目标都要比大目标容易达成，小目标可以累积成大目标。<br>不是：“我打算要写那份报告。”<br>而是：“今晚我将花半个小时设计表格。明天我将花另外半个小时把数据填进去，再接下来一天，我将根据那些数据花一个小时<br>将报告写出来。”<br>4.现实地（而不是按照自己的愿望）对待时间。问自己：这个任务事实上将花去我多少时间？我真正能抽出多少时间投入其中？<br>不是：“明天我有充足的时间去做这件事。”<br>而是：“我最好看一下我的日程表，看看我什么时候可以开始做。上次那件事所花的时间超出了我的预期。”<br>5.只管开始做！不要想一下子做完整件事情，每次只要迈出一小步。<br>记住：“千里之行始于足下。”<br>不是：“我一坐下来就要把事情做完。”<br>而是：“我可以采取的第一个行动是什么？”<br>6.利用接下来的15分钟。任何事情你都可以忍受15分钟。你只能通过一次又一次的15分钟才能完成一件事情。因此，你在15分钟时<br>间内所做的事情是相当有意义的。<br>不是：“我只有15分钟时间了，何必费力去做呢？”<br>而是：“在接下来的15分钟时间内，这件事的哪个部分我可以上手去做呢？”<br>7.为困难和挫折做好心理准备。当你遭遇到第一个（或者第二、第三个）困难时，不要放弃。困难只不过是一个需要你去<br>解决的问题，它不是你个人价值或能力的反映。不是：“教授不在办公室，所以我没办法写论文了。我想去看场电影。”<br>而是：“虽然教授不在，但是我可以在他回来之前先列出论文提纲。”<br>8.可能的话，将任务分派出去（甚至扔掉不管！）。你真的是能够做这件事的唯一人选吗？这件事情真的有必要去做吗？<br>记住：没有人可以什么事情都做——你也是。<br>不是：“我是唯一一个可以做好这件事的人。”<br>而是：“我会给这件事找个合适的人来做，这样我就可以去做更重要的事了。”<br>9.保护你的时间。学会怎样说不，不要去做额外的或者不必要的事情。<br>为了从事重要的事务，你可以决定对“急迫”的事情置之不理。<br>不是：“我必须对任何需要我的人有求必应。”<br>而是：“在工作的时候，我没必要接听电话。我会收看留言，然后在我做完事情后再回电。”<br>10.留意你的借口。不要习惯性地利用借口来拖延，而要将它看做是再做15分钟的一个信号。或者利用你的借口作为完成一个步骤<br>之后的奖赏。不是：“我累了（抑郁/饿了/很忙/很烦，等等），我以后再做。”<br>而是：“我累了，所以我将只花15分钟写报告，接下来我会小睡片刻。”<br>11.奖赏你一路上的进步。将奖赏聚焦于你的努力，而不是结果。小心非此即彼的思维方式：你可以说杯子是半空的，也可以说它<br>是半满的。住：即便是迈出一小步也是进步。<br>不是：“除非我全部完成，否则我就会感觉哪里不对。”<br>而是：“我已经走出了几步，而且我做事非常努力，这感觉很好。现在我打算去看一部电影。”<br>12.将拖延看成是一个信号。停下来问自己：“拖延传递给我的是什么信息？”<br>不是：“我又在拖延，我恨我自己。”<br>而是：“我又在拖延，我的感受是怎样的？它意味着什么？我可以从中学到什么？”<br>记住：你能够做出自己的选择。你可以拖延，你也可以行动。<br>即便在你心里不舒服的时候，你还是可以行动。<br>以往的历史无法决定你当下要怎样做。<br>你可以从学习、成长和挑战自己中获得快乐。<br>你不必等到完美之后才觉得自己具有价值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站筆記</title>
      <link href="2020/11/26/build-blog-note/"/>
      <url>2020/11/26/build-blog-note/</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令备忘"><a href="#基本命令备忘" class="headerlink" title="基本命令备忘"></a>基本命令备忘</h2><p><strong>清除 构建 本地部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>默认本地url:<a href="http://localhost:4000/" title="http://localhost:4000/">http://localhost:4000</a></p><p><strong>清除 构建 提交远程（github）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo d -m &quot;提交备注&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="建站帮助连接"><a href="#建站帮助连接" class="headerlink" title="建站帮助连接"></a>建站帮助连接</h2><p><a href="https://www.bilibili.com/video/av370050627" title="免费搭建属于自己的个人博客网站">视频教程</a></p><p><a href="https://bet-yc.top/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%96%87%E5%AD%97%E6%95%99%E7%A8%8B%E5%86%85%E5%90%AB%E6%89%80%E9%9C%80%E4%BB%A3%E7%A0%81/#more" title="免费搭建属于自己的个人博客网站">文字教程</a></p><p><a href="https://www.jianshu.com/p/ec4e678f6cef">更换主题</a></p><p><a href="https://cloud.tencent.com/developer/article/1078192" title="导入码云，通过码云下载">gitgub下载慢的替代方案</a></p><p><a href="https://www.zhihu.com/question/29017171" title="hexo 下的分类和表签无法显示，怎么解决？">个人踩得坑</a></p><p><a href="https://hexo.io/zh-cn/docs/">hexo的API文档</a></p><p><a href="https://www.jianshu.com/p/191d1e21f7ed/">Markdown基本语法</a></p><p><a href="https://blog.csdn.net/heimu24/article/details/81189700/">Markdown进阶</a></p><p><a href="https://www.w3school.com.cn/cssref/css_colors.asp">CSS颜色</a></p><p><a href="https://segmentfault.com/a/1190000014085547">为Hexo添加Gitalk评论插件</a></p><p><a href="https://www.cnblogs.com/treeskyer/p/13966061.html">一款超好用的第三方评论插件–Gitalk</a></p><hr><hr><center><font face="楷体" size="10" color="#00a0e9"><strong>欲善其事，必利其器</strong></font></center>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/26/hello-world/"/>
      <url>2020/11/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
